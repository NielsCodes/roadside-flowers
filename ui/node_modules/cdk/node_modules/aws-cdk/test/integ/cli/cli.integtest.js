"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const os = require("os");
const path = require("path");
const aws_helpers_1 = require("./aws-helpers");
const cdk_helpers_1 = require("./cdk-helpers");
const test_helpers_1 = require("./test-helpers");
jest.setTimeout(600 * 1000);
beforeAll(async () => {
    await cdk_helpers_1.prepareAppFixture();
});
beforeEach(async () => {
    await cdk_helpers_1.cleanup();
});
afterEach(async () => {
    await cdk_helpers_1.cleanup();
});
test_helpers_1.integTest('VPC Lookup', async () => {
    cdk_helpers_1.log('Making sure we are clean before starting.');
    await cdk_helpers_1.cdkDestroy('define-vpc', { modEnv: { ENABLE_VPC_TESTING: 'DEFINE' } });
    cdk_helpers_1.log('Setting up: creating a VPC with known tags');
    await cdk_helpers_1.cdkDeploy('define-vpc', { modEnv: { ENABLE_VPC_TESTING: 'DEFINE' } });
    cdk_helpers_1.log('Setup complete!');
    cdk_helpers_1.log('Verifying we can now import that VPC');
    await cdk_helpers_1.cdkDeploy('import-vpc', { modEnv: { ENABLE_VPC_TESTING: 'IMPORT' } });
});
test_helpers_1.integTest('Two ways of shoing the version', async () => {
    const version1 = await cdk_helpers_1.cdk(['version']);
    const version2 = await cdk_helpers_1.cdk(['--version']);
    expect(version1).toEqual(version2);
});
test_helpers_1.integTest('Termination protection', async () => {
    const stackName = 'termination-protection';
    await cdk_helpers_1.cdkDeploy(stackName);
    // Try a destroy that should fail
    await expect(cdk_helpers_1.cdkDestroy(stackName)).rejects.toThrow('exited with error');
    // Can update termination protection even though the change set doesn't contain changes
    await cdk_helpers_1.cdkDeploy(stackName, { modEnv: { TERMINATION_PROTECTION: 'FALSE' } });
    await cdk_helpers_1.cdkDestroy(stackName);
});
test_helpers_1.integTest('cdk synth', async () => {
    await expect(cdk_helpers_1.cdk(['synth', cdk_helpers_1.fullStackName('test-1')])).resolves.toEqual(`Resources:
  topic69831491:
    Type: AWS::SNS::Topic
    Metadata:
      aws:cdk:path: ${cdk_helpers_1.STACK_NAME_PREFIX}-test-1/topic/Resource`);
    await expect(cdk_helpers_1.cdk(['synth', cdk_helpers_1.fullStackName('test-2')])).resolves.toEqual(`Resources:
  topic152D84A37:
    Type: AWS::SNS::Topic
    Metadata:
      aws:cdk:path: ${cdk_helpers_1.STACK_NAME_PREFIX}-test-2/topic1/Resource
  topic2A4FB547F:
    Type: AWS::SNS::Topic
    Metadata:
      aws:cdk:path: ${cdk_helpers_1.STACK_NAME_PREFIX}-test-2/topic2/Resource`);
});
test_helpers_1.integTest('ssm parameter provider error', async () => {
    await expect(cdk_helpers_1.cdk(['synth',
        cdk_helpers_1.fullStackName('missing-ssm-parameter'),
        '-c', 'test:ssm-parameter-name=/does/not/exist',
    ], {
        allowErrExit: true,
    })).resolves.toContain('SSM parameter not available in account');
});
test_helpers_1.integTest('automatic ordering', async () => {
    // Deploy the consuming stack which will include the producing stack
    await cdk_helpers_1.cdkDeploy('order-consuming');
    // Destroy the providing stack which will include the consuming stack
    await cdk_helpers_1.cdkDestroy('order-providing');
});
test_helpers_1.integTest('context setting', async () => {
    await fs_1.promises.writeFile(path.join(cdk_helpers_1.INTEG_TEST_DIR, 'cdk.context.json'), JSON.stringify({
        contextkey: 'this is the context value',
    }));
    try {
        await expect(cdk_helpers_1.cdk(['context'])).resolves.toContain('this is the context value');
        // Test that deleting the contextkey works
        await cdk_helpers_1.cdk(['context', '--reset', 'contextkey']);
        await expect(cdk_helpers_1.cdk(['context'])).resolves.not.toContain('this is the context value');
        // Test that forced delete of the context key does not throw
        await cdk_helpers_1.cdk(['context', '-f', '--reset', 'contextkey']);
    }
    finally {
        await fs_1.promises.unlink(path.join(cdk_helpers_1.INTEG_TEST_DIR, 'cdk.context.json'));
    }
});
test_helpers_1.integTest('deploy', async () => {
    var _a;
    const stackArn = await cdk_helpers_1.cdkDeploy('test-2', { captureStderr: false });
    // verify the number of resources in the stack
    const response = await aws_helpers_1.cloudFormation('describeStackResources', {
        StackName: stackArn,
    });
    expect((_a = response.StackResources) === null || _a === void 0 ? void 0 : _a.length).toEqual(2);
});
test_helpers_1.integTest('deploy all', async () => {
    const arns = await cdk_helpers_1.cdkDeploy('test-*', { captureStderr: false });
    // verify that we only deployed a single stack (there's a single ARN in the output)
    expect(arns.split('\n').length).toEqual(2);
});
test_helpers_1.integTest('nested stack with parameters', async () => {
    var _a;
    // STACK_NAME_PREFIX is used in MyTopicParam to allow multiple instances
    // of this test to run in parallel, othewise they will attempt to create the same SNS topic.
    const stackArn = await cdk_helpers_1.cdkDeploy('with-nested-stack-using-parameters', {
        options: ['--parameters', 'MyTopicParam=${STACK_NAME_PREFIX}ThereIsNoSpoon'],
        captureStderr: false,
    });
    // verify that we only deployed a single stack (there's a single ARN in the output)
    expect(stackArn.split('\n').length).toEqual(1);
    // verify the number of resources in the stack
    const response = await aws_helpers_1.cloudFormation('describeStackResources', {
        StackName: stackArn,
    });
    expect((_a = response.StackResources) === null || _a === void 0 ? void 0 : _a.length).toEqual(1);
});
test_helpers_1.integTest('deploy without execute', async () => {
    var _a;
    const stackArn = await cdk_helpers_1.cdkDeploy('test-2', {
        options: ['--no-execute'],
        captureStderr: false,
    });
    // verify that we only deployed a single stack (there's a single ARN in the output)
    expect(stackArn.split('\n').length).toEqual(1);
    const response = await aws_helpers_1.cloudFormation('describeStacks', {
        StackName: stackArn,
    });
    expect((_a = response.Stacks) === null || _a === void 0 ? void 0 : _a[0].StackStatus).toEqual('REVIEW_IN_PROGRESS');
});
test_helpers_1.integTest('security related changes without a CLI are expected to fail', async () => {
    // redirect /dev/null to stdin, which means there will not be tty attached
    // since this stack includes security-related changes, the deployment should
    // immediately fail because we can't confirm the changes
    const stackName = 'iam-test';
    await expect(cdk_helpers_1.cdkDeploy(stackName, {
        options: ['<', '/dev/null'],
        neverRequireApproval: false,
    })).rejects.toThrow('exited with error');
    // Ensure stack was not deployed
    await expect(aws_helpers_1.cloudFormation('describeStacks', {
        StackName: cdk_helpers_1.fullStackName(stackName),
    })).rejects.toThrow('does not exist');
});
test_helpers_1.integTest('deploy wildcard with outputs', async () => {
    const outputsFile = path.join(cdk_helpers_1.INTEG_TEST_DIR, 'outputs', 'outputs.json');
    await fs_1.promises.mkdir(path.dirname(outputsFile), { recursive: true });
    await cdk_helpers_1.cdkDeploy(['outputs-test-*'], {
        options: ['--outputs-file', outputsFile],
    });
    const outputs = JSON.parse((await fs_1.promises.readFile(outputsFile, { encoding: 'utf-8' })).toString());
    expect(outputs).toEqual({
        [`${cdk_helpers_1.STACK_NAME_PREFIX}-outputs-test-1`]: {
            TopicName: `${cdk_helpers_1.STACK_NAME_PREFIX}-outputs-test-1MyTopic`,
        },
        [`${cdk_helpers_1.STACK_NAME_PREFIX}-outputs-test-2`]: {
            TopicName: `${cdk_helpers_1.STACK_NAME_PREFIX}-outputs-test-2MyOtherTopic`,
        },
    });
});
test_helpers_1.integTest('deploy with parameters', async () => {
    var _a;
    const stackArn = await cdk_helpers_1.cdkDeploy('param-test-1', {
        options: [
            '--parameters', `TopicNameParam=${cdk_helpers_1.STACK_NAME_PREFIX}bazinga`,
        ],
        captureStderr: false,
    });
    const response = await aws_helpers_1.cloudFormation('describeStacks', {
        StackName: stackArn,
    });
    expect((_a = response.Stacks) === null || _a === void 0 ? void 0 : _a[0].Parameters).toEqual([
        {
            ParameterKey: 'TopicNameParam',
            ParameterValue: `${cdk_helpers_1.STACK_NAME_PREFIX}bazinga`,
        },
    ]);
});
test_helpers_1.integTest('deploy with wildcard and parameters', async () => {
    await cdk_helpers_1.cdkDeploy('param-test-*', {
        options: [
            '--parameters', `${cdk_helpers_1.STACK_NAME_PREFIX}-param-test-1:TopicNameParam=${cdk_helpers_1.STACK_NAME_PREFIX}bazinga`,
            '--parameters', `${cdk_helpers_1.STACK_NAME_PREFIX}-param-test-2:OtherTopicNameParam=${cdk_helpers_1.STACK_NAME_PREFIX}ThatsMySpot`,
            '--parameters', `${cdk_helpers_1.STACK_NAME_PREFIX}-param-test-3:DisplayNameParam=${cdk_helpers_1.STACK_NAME_PREFIX}HeyThere`,
            '--parameters', `${cdk_helpers_1.STACK_NAME_PREFIX}-param-test-3:OtherDisplayNameParam=${cdk_helpers_1.STACK_NAME_PREFIX}AnotherOne`,
        ],
    });
});
test_helpers_1.integTest('deploy with parameters multi', async () => {
    var _a;
    const paramVal1 = `${cdk_helpers_1.STACK_NAME_PREFIX}bazinga`;
    const paramVal2 = `${cdk_helpers_1.STACK_NAME_PREFIX}=jagshemash`;
    const stackArn = await cdk_helpers_1.cdkDeploy('param-test-3', {
        options: [
            '--parameters', `DisplayNameParam=${paramVal1}`,
            '--parameters', `OtherDisplayNameParam=${paramVal2}`,
        ],
        captureStderr: false,
    });
    const response = await aws_helpers_1.cloudFormation('describeStacks', {
        StackName: stackArn,
    });
    expect((_a = response.Stacks) === null || _a === void 0 ? void 0 : _a[0].Parameters).toEqual([
        {
            ParameterKey: 'DisplayNameParam',
            ParameterValue: paramVal1,
        },
        {
            ParameterKey: 'OtherDisplayNameParam',
            ParameterValue: paramVal2,
        },
    ]);
});
test_helpers_1.integTest('deploy with notification ARN', async () => {
    var _a;
    const topicName = `${cdk_helpers_1.STACK_NAME_PREFIX}-test-topic`;
    const response = await aws_helpers_1.sns('createTopic', { Name: topicName });
    const topicArn = response.TopicArn;
    try {
        await cdk_helpers_1.cdkDeploy('test-2', {
            options: ['--notification-arns', topicArn],
        });
        // verify that the stack we deployed has our notification ARN
        const describeResponse = await aws_helpers_1.cloudFormation('describeStacks', {
            StackName: cdk_helpers_1.fullStackName('test-2'),
        });
        expect((_a = describeResponse.Stacks) === null || _a === void 0 ? void 0 : _a[0].NotificationARNs).toEqual([topicArn]);
    }
    finally {
        await aws_helpers_1.sns('deleteTopic', {
            TopicArn: topicArn,
        });
    }
});
test_helpers_1.integTest('deploy with role', async () => {
    const roleName = `${cdk_helpers_1.STACK_NAME_PREFIX}-test-role`;
    await deleteRole();
    const createResponse = await aws_helpers_1.iam('createRole', {
        RoleName: roleName,
        AssumeRolePolicyDocument: JSON.stringify({
            Version: '2012-10-17',
            Statement: [{
                    Action: 'sts:AssumeRole',
                    Principal: { Service: 'cloudformation.amazonaws.com' },
                    Effect: 'Allow',
                }, {
                    Action: 'sts:AssumeRole',
                    Principal: { AWS: (await aws_helpers_1.sts('getCallerIdentity', {})).Arn },
                    Effect: 'Allow',
                }],
        }),
    });
    const roleArn = createResponse.Role.Arn;
    try {
        await aws_helpers_1.iam('putRolePolicy', {
            RoleName: roleName,
            PolicyName: 'DefaultPolicy',
            PolicyDocument: JSON.stringify({
                Version: '2012-10-17',
                Statement: [{
                        Action: '*',
                        Resource: '*',
                        Effect: 'Allow',
                    }],
            }),
        });
        await aws_helpers_1.retry('Trying to assume fresh role', aws_helpers_1.retry.forSeconds(300), async () => {
            await aws_helpers_1.sts('assumeRole', {
                RoleArn: roleArn,
                RoleSessionName: 'testing',
            });
        });
        // In principle, the role has replicated from 'us-east-1' to wherever we're testing.
        // Give it a little more sleep to make sure CloudFormation is not hitting a box
        // that doesn't have it yet.
        await aws_helpers_1.sleep(5000);
        await cdk_helpers_1.cdkDeploy('test-2', {
            options: ['--role-arn', roleArn],
        });
        // Immediately delete the stack again before we delete the role.
        //
        // Since roles are sticky, if we delete the role before the stack, subsequent DeleteStack
        // operations will fail when CloudFormation tries to assume the role that's already gone.
        await cdk_helpers_1.cdkDestroy('test-2');
    }
    finally {
        await deleteRole();
    }
    async function deleteRole() {
        try {
            // tslint:disable-next-line: forin
            for (const policyName of (await aws_helpers_1.iam('listRolePolicies', { RoleName: roleName })).PolicyNames) {
                await aws_helpers_1.iam('deleteRolePolicy', {
                    RoleName: roleName,
                    PolicyName: policyName,
                });
            }
            await aws_helpers_1.iam('deleteRole', { RoleName: roleName });
        }
        catch (e) {
            if (e.message.indexOf('cannot be found') > -1) {
                return;
            }
            throw e;
        }
    }
});
test_helpers_1.integTest('cdk diff', async () => {
    const diff1 = await cdk_helpers_1.cdk(['diff', cdk_helpers_1.fullStackName('test-1')]);
    expect(diff1).toContain('AWS::SNS::Topic');
    const diff2 = await cdk_helpers_1.cdk(['diff', cdk_helpers_1.fullStackName('test-2')]);
    expect(diff2).toContain('AWS::SNS::Topic');
    // We can make it fail by passing --fail
    await expect(cdk_helpers_1.cdk(['diff', '--fail', cdk_helpers_1.fullStackName('test-1')]))
        .rejects.toThrow('exited with error');
});
test_helpers_1.integTest('deploy stack with docker asset', async () => {
    await cdk_helpers_1.cdkDeploy('docker');
});
test_helpers_1.integTest('deploy and test stack with lambda asset', async () => {
    var _a, _b;
    const stackArn = await cdk_helpers_1.cdkDeploy('lambda', { captureStderr: false });
    const response = await aws_helpers_1.cloudFormation('describeStacks', {
        StackName: stackArn,
    });
    const lambdaArn = (_b = (_a = response.Stacks) === null || _a === void 0 ? void 0 : _a[0].Outputs) === null || _b === void 0 ? void 0 : _b[0].OutputValue;
    if (lambdaArn === undefined) {
        throw new Error('Stack did not have expected Lambda ARN output');
    }
    const output = await aws_helpers_1.lambda('invoke', {
        FunctionName: lambdaArn,
    });
    expect(JSON.stringify(output.Payload)).toContain('dear asset');
});
test_helpers_1.integTest('cdk ls', async () => {
    const listing = await cdk_helpers_1.cdk(['ls'], { captureStderr: false });
    const expectedStacks = [
        'conditional-resource',
        'docker',
        'docker-with-custom-file',
        'failed',
        'iam-test',
        'lambda',
        'missing-ssm-parameter',
        'order-providing',
        'outputs-test-1',
        'outputs-test-2',
        'param-test-1',
        'param-test-2',
        'param-test-3',
        'termination-protection',
        'test-1',
        'test-2',
        'with-nested-stack',
        'with-nested-stack-using-parameters',
        'order-consuming',
    ];
    for (const stack of expectedStacks) {
        expect(listing).toContain(cdk_helpers_1.fullStackName(stack));
    }
});
test_helpers_1.integTest('deploy stack without resource', async () => {
    // Deploy the stack without resources
    await cdk_helpers_1.cdkDeploy('conditional-resource', { modEnv: { NO_RESOURCE: 'TRUE' } });
    // This should have succeeded but not deployed the stack.
    await expect(aws_helpers_1.cloudFormation('describeStacks', { StackName: cdk_helpers_1.fullStackName('conditional-resource') }))
        .rejects.toThrow('conditional-resource does not exist');
    // Deploy the stack with resources
    await cdk_helpers_1.cdkDeploy('conditional-resource');
    // Then again WITHOUT resources (this should destroy the stack)
    await cdk_helpers_1.cdkDeploy('conditional-resource', { modEnv: { NO_RESOURCE: 'TRUE' } });
    await expect(aws_helpers_1.cloudFormation('describeStacks', { StackName: cdk_helpers_1.fullStackName('conditional-resource') }))
        .rejects.toThrow('conditional-resource does not exist');
});
test_helpers_1.integTest('IAM diff', async () => {
    const output = await cdk_helpers_1.cdk(['diff', cdk_helpers_1.fullStackName('iam-test')]);
    // Roughly check for a table like this:
    //
    // ┌───┬─────────────────┬────────┬────────────────┬────────────────────────────-──┬───────────┐
    // │   │ Resource        │ Effect │ Action         │ Principal                     │ Condition │
    // ├───┼─────────────────┼────────┼────────────────┼───────────────────────────────┼───────────┤
    // │ + │ ${SomeRole.Arn} │ Allow  │ sts:AssumeRole │ Service:ec2.amazonaws.com     │           │
    // └───┴─────────────────┴────────┴────────────────┴───────────────────────────────┴───────────┘
    expect(output).toContain('${SomeRole.Arn}');
    expect(output).toContain('sts:AssumeRole');
    expect(output).toContain('ec2.amazonaws.com');
});
test_helpers_1.integTest('fast deploy', async () => {
    // we are using a stack with a nested stack because CFN will always attempt to
    // update a nested stack, which will allow us to verify that updates are actually
    // skipped unless --force is specified.
    const stackArn = await cdk_helpers_1.cdkDeploy('with-nested-stack', { captureStderr: false });
    const changeSet1 = await getLatestChangeSet();
    // Deploy the same stack again, there should be no new change set created
    await cdk_helpers_1.cdkDeploy('with-nested-stack');
    const changeSet2 = await getLatestChangeSet();
    expect(changeSet2.ChangeSetId).toEqual(changeSet1.ChangeSetId);
    // Deploy the stack again with --force, now we should create a changeset
    await cdk_helpers_1.cdkDeploy('with-nested-stack', { options: ['--force'] });
    const changeSet3 = await getLatestChangeSet();
    expect(changeSet3.ChangeSetId).not.toEqual(changeSet2.ChangeSetId);
    // Deploy the stack again with tags, expected to create a new changeset
    // even though the resources didn't change.
    await cdk_helpers_1.cdkDeploy('with-nested-stack', { options: ['--tags', 'key=value'] });
    const changeSet4 = await getLatestChangeSet();
    expect(changeSet4.ChangeSetId).not.toEqual(changeSet3.ChangeSetId);
    async function getLatestChangeSet() {
        var _a, _b, _c;
        const response = await aws_helpers_1.cloudFormation('describeStacks', { StackName: stackArn });
        if (!((_a = response.Stacks) === null || _a === void 0 ? void 0 : _a[0])) {
            throw new Error('Did not get a ChangeSet at all');
        }
        cdk_helpers_1.log(`Found Change Set ${(_b = response.Stacks) === null || _b === void 0 ? void 0 : _b[0].ChangeSetId}`);
        return (_c = response.Stacks) === null || _c === void 0 ? void 0 : _c[0];
    }
});
test_helpers_1.integTest('failed deploy does not hang', async () => {
    // this will hang if we introduce https://github.com/aws/aws-cdk/issues/6403 again.
    await expect(cdk_helpers_1.cdkDeploy('failed')).rejects.toThrow('exited with error');
});
test_helpers_1.integTest('can still load old assemblies', async () => {
    const cxAsmDir = path.join(os.tmpdir(), 'cdk-integ-cx');
    const testAssembliesDirectory = path.join(__dirname, 'cloud-assemblies');
    for (const asmdir of await listChildDirs(testAssembliesDirectory)) {
        cdk_helpers_1.log(`ASSEMBLY ${asmdir}`);
        await cdk_helpers_1.cloneDirectory(asmdir, cxAsmDir);
        // Some files in the asm directory that have a .js extension are
        // actually treated as templates. Evaluate them using NodeJS.
        const templates = await listChildren(cxAsmDir, fullPath => Promise.resolve(fullPath.endsWith('.js')));
        for (const template of templates) {
            const targetName = template.replace(/.js$/, '');
            await cdk_helpers_1.shell([process.execPath, template, '>', targetName], {
                cwd: cxAsmDir,
                modEnv: {
                    TEST_ACCOUNT: (await aws_helpers_1.testEnv()).account,
                    TEST_REGION: (await aws_helpers_1.testEnv()).region,
                },
            });
        }
        // Use this directory as a Cloud Assembly
        const output = await cdk_helpers_1.cdk([
            '--app', cxAsmDir,
            '-v',
            'synth'
        ]);
        // Assert that there was no providerError in CDK's stderr
        // Because we rely on the app/framework to actually error in case the
        // provider fails, we inspect the logs here.
        expect(output).not.toContain('$providerError');
    }
});
test_helpers_1.integTest('generating and loading assembly', async () => {
    const asmOutputDir = path.join(os.tmpdir(), 'cdk-integ-asm');
    await cdk_helpers_1.shell(['rm', '-rf', asmOutputDir]);
    // Make sure our fixture directory is clean
    await cdk_helpers_1.prepareAppFixture();
    // Synthesize a Cloud Assembly tothe default directory (cdk.out) and a specific directory.
    await cdk_helpers_1.cdk(['synth']);
    await cdk_helpers_1.cdk(['synth', '--output', asmOutputDir]);
    // cdk.out in the current directory and the indicated --output should be the same
    await cdk_helpers_1.shell(['diff', 'cdk.out', asmOutputDir], {
        cwd: cdk_helpers_1.INTEG_TEST_DIR,
    });
    // Check that we can 'ls' the synthesized asm.
    // Change to some random directory to make sure we're not accidentally loading cdk.json
    const list = await cdk_helpers_1.cdk(['--app', asmOutputDir, 'ls'], { cwd: os.tmpdir() });
    // Same stacks we know are in the app
    expect(list).toContain(`${cdk_helpers_1.STACK_NAME_PREFIX}-lambda`);
    expect(list).toContain(`${cdk_helpers_1.STACK_NAME_PREFIX}-test-1`);
    expect(list).toContain(`${cdk_helpers_1.STACK_NAME_PREFIX}-test-2`);
    // Check that we can use '.' and just synth ,the generated asm
    const stackTemplate = await cdk_helpers_1.cdk(['--app', '.', 'synth', cdk_helpers_1.fullStackName('test-2')], {
        cwd: asmOutputDir,
    });
    expect(stackTemplate).toContain('topic152D84A37');
    // Deploy a Lambda from the copied asm
    await cdk_helpers_1.cdkDeploy('lambda', { options: ['-a', '.'], cwd: asmOutputDir });
    // Remove the original custom docker file that was used during synth.
    // this verifies that the assemly has a copy of it and that the manifest uses
    // relative paths to reference to it.
    await fs_1.promises.unlink(path.join(cdk_helpers_1.INTEG_TEST_DIR, 'docker', 'Dockerfile.Custom'));
    // deploy a docker image with custom file without synth (uses assets)
    await cdk_helpers_1.cdkDeploy('docker-with-custom-file', { options: ['-a', '.'], cwd: asmOutputDir });
});
async function listChildren(parent, pred) {
    const ret = new Array();
    for (const child of await fs_1.promises.readdir(parent, { encoding: 'utf-8' })) {
        const fullPath = path.join(parent, child.toString());
        if (await pred(fullPath)) {
            ret.push(fullPath);
        }
    }
    return ret;
}
async function listChildDirs(parent) {
    return listChildren(parent, async (fullPath) => (await fs_1.promises.stat(fullPath)).isDirectory());
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLmludGVndGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNsaS5pbnRlZ3Rlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQkFBb0M7QUFDcEMseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwrQ0FBNkY7QUFDN0YsK0NBQzBGO0FBQzFGLGlEQUEyQztBQUUzQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUU1QixTQUFTLENBQUMsS0FBSyxJQUFJLEVBQUU7SUFDbkIsTUFBTSwrQkFBaUIsRUFBRSxDQUFDO0FBQzVCLENBQUMsQ0FBQyxDQUFDO0FBRUgsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO0lBQ3BCLE1BQU0scUJBQU8sRUFBRSxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxDQUFDO0FBRUgsU0FBUyxDQUFDLEtBQUssSUFBSSxFQUFFO0lBQ25CLE1BQU0scUJBQU8sRUFBRSxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxDQUFDO0FBRUgsd0JBQVMsQ0FBQyxZQUFZLEVBQUUsS0FBSyxJQUFJLEVBQUU7SUFDakMsaUJBQUcsQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO0lBQ2pELE1BQU0sd0JBQVUsQ0FBQyxZQUFZLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxrQkFBa0IsRUFBRSxRQUFRLEVBQUUsRUFBQyxDQUFDLENBQUM7SUFFNUUsaUJBQUcsQ0FBQyw0Q0FBNEMsQ0FBQyxDQUFDO0lBQ2xELE1BQU0sdUJBQVMsQ0FBQyxZQUFZLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxrQkFBa0IsRUFBRSxRQUFRLEVBQUUsRUFBQyxDQUFDLENBQUM7SUFDM0UsaUJBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0lBRXZCLGlCQUFHLENBQUMsc0NBQXNDLENBQUMsQ0FBQztJQUM1QyxNQUFNLHVCQUFTLENBQUMsWUFBWSxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsUUFBUSxF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QUcsR0FBRyxJQUFJLEtBQUssRUFBVSxDQUFDO0lBQ2hDLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxhQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFO1FBQ25FLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3JELElBQUksTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDeEIsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNwQjtLQUNGO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBRUQsS0FBSyxVQUFVLGFBQWEsQ0FBQyxNQUFjO0lBQ3pDLE9BQU8sWUFBWSxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsUUFBZ0IsRUFBRSxFQUFFLENBQUMsQ0FBQyxNQUFNLGFBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0FBQ25HLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIG9zIGZyb20gJ29zJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBjbG91ZEZvcm1hdGlvbiwgaWFtLCBsYW1iZGEsIHJldHJ5LCBzbGVlcCwgc25zLCBzdHMsIHRlc3RFbnYgfSBmcm9tICcuL2F3cy1oZWxwZXJzJztcbmltcG9ydCB7IGNkaywgY2RrRGVwbG95LCBjZGtEZXN0cm95LCBjbGVhbnVwLCBjbG9uZURpcmVjdG9yeSwgZnVsbFN0YWNrTmFtZSxcbiAgSU5URUdfVEVTVF9ESVIsIGxvZywgcHJlcGFyZUFwcEZpeHR1cmUsIHNoZWxsLCBTVEFDS19OQU1FX1BSRUZJWCB9IGZyb20gJy4vY2RrLWhlbHBlcnMnO1xuaW1wb3J0IHsgaW50ZWdUZXN0IH0gZnJvbSAnLi90ZXN0LWhlbHBlcnMnO1xuXG5qZXN0LnNldFRpbWVvdXQoNjAwICogMTAwMCk7XG5cbmJlZm9yZUFsbChhc3luYyAoKSA9PiB7XG4gIGF3YWl0IHByZXBhcmVBcHBGaXh0dXJlKCk7XG59KTtcblxuYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gIGF3YWl0IGNsZWFudXAoKTtcbn0pO1xuXG5hZnRlckVhY2goYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBjbGVhbnVwKCk7XG59KTtcblxuaW50ZWdUZXN0KCdWUEMgTG9va3VwJywgYXN5bmMgKCkgPT4ge1xuICBsb2coJ01ha2luZyBzdXJlIHdlIGFyZSBjbGVhbiBiZWZvcmUgc3RhcnRpbmcuJyk7XG4gIGF3YWl0IGNka0Rlc3Ryb3koJ2RlZmluZS12cGMnLCB7IG1vZEVudjogeyBFTkFCTEVfVlBDX1RFU1RJTkc6ICdERUZJTkUnIH19KTtcblxuICBsb2coJ1NldHRpbmcgdXA6IGNyZWF0aW5nIGEgVlBDIHdpdGgga25vd24gdGFncycpO1xuICBhd2FpdCBjZGtEZXBsb3koJ2RlZmluZS12cGMnLCB7IG1vZEVudjogeyBFTkFCTEVfVlBDX1RFU1RJTkc6ICdERUZJTkUnIH19KTtcbiAgbG9nKCdTZXR1cCBjb21wbGV0ZSEnKTtcblxuICBsb2coJ1ZlcmlmeWluZyB3ZSBjYW4gbm93IGltcG9ydCB0aGF0IFZQQycpO1xuICBhd2FpdCBjZGtEZXBsb3koJ2ltcG9ydC12cGMnLCB7IG1vZEVudjogeyBFTkFCTEVfVlBDX1RFU1RJTkc6ICdJTVBPUlQnIH19KTtcbn0pO1xuXG5pbnRlZ1Rlc3QoJ1R3byB3YXlzIG9mIHNob2luZyB0aGUgdmVyc2lvbicsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgdmVyc2lvbjEgPSBhd2FpdCBjZGsoWyd2ZXJzaW9uJ10pO1xuICBjb25zdCB2ZXJzaW9uMiA9IGF3YWl0IGNkayhbJy0tdmVyc2lvbiddKTtcblxuICBleHBlY3QodmVyc2lvbjEpLnRvRXF1YWwodmVyc2lvbjIpO1xufSk7XG5cbmludGVnVGVzdCgnVGVybWluYXRpb24gcHJvdGVjdGlvbicsIGFzeW5jICgpID0+IHtcbiAgY29uc3Qgc3RhY2tOYW1lID0gJ3Rlcm1pbmF0aW9uLXByb3RlY3Rpb24nO1xuICBhd2FpdCBjZGtEZXBsb3koc3RhY2tOYW1lKTtcblxuICAvLyBUcnkgYSBkZXN0cm95IHRoYXQgc2hvdWxkIGZhaWxcbiAgYXdhaXQgZXhwZWN0KGNka0Rlc3Ryb3koc3RhY2tOYW1lKSkucmVqZWN0cy50b1Rocm93KCdleGl0ZWQgd2l0aCBlcnJvcicpO1xuXG4gIC8vIENhbiB1cGRhdGUgdGVybWluYXRpb24gcHJvdGVjdGlvbiBldmVuIHRob3VnaCB0aGUgY2hhbmdlIHNldCBkb2Vzbid0IGNvbnRhaW4gY2hhbmdlc1xuICBhd2FpdCBjZGtEZXBsb3koc3RhY2tOYW1lLCB7IG1vZEVudjogeyBURVJNSU5BVElPTl9QUk9URUNUSU9OOiAnRkFMU0UnIH0gfSk7XG4gIGF3YWl0IGNka0Rlc3Ryb3koc3RhY2tOYW1lKTtcbn0pO1xuXG5pbnRlZ1Rlc3QoJ2NkayBzeW50aCcsIGFzeW5jICgpID0+IHtcbiAgYXdhaXQgZXhwZWN0KGNkayhbJ3N5bnRoJywgZnVsbFN0YWNrTmFtZSgndGVzdC0xJyldKSkucmVzb2x2ZXMudG9FcXVhbChcbiAgICBgUmVzb3VyY2VzOlxuICB0b3BpYzY5ODMxNDkxOlxuICAgIFR5cGU6IEFXUzo6U05TOjpUb3BpY1xuICAgIE1ldGFkYXRhOlxuICAgICAgYXdzOmNkazpwYXRoOiAke1NUQUNLX05BTUVfUFJFRklYfS10ZXN0LTEvdG9waWMvUmVzb3VyY2VgKTtcblxuICBhd2FpdCBleHBlY3QoY2RrKFsnc3ludGgnLCBmdWxsU3RhY2tOYW1lKCd0ZXN0LTInKV0pKS5yZXNvbHZlcy50b0VxdWFsKFxuICAgIGBSZXNvdXJjZXM6XG4gIHRvcGljMTUyRDg0QTM3OlxuICAgIFR5cGU6IEFXUzo6U05TOjpUb3BpY1xuICAgIE1ldGFkYXRhOlxuICAgICAgYXdzOmNkazpwYXRoOiAke1NUQUNLX05BTUVfUFJFRklYfS10ZXN0LTIvdG9waWMxL1Jlc291cmNlXG4gIHRvcGljMkE0RkI1NDdGOlxuICAgIFR5cGU6IEFXUzo6U05TOjpUb3BpY1xuICAgIE1ldGFkYXRhOlxuICAgICAgYXdzOmNkazpwYXRoOiAke1NUQUNLX05BTUVfUFJFRklYfS10ZXN0LTIvdG9waWMyL1Jlc291cmNlYCk7XG59KTtcblxuaW50ZWdUZXN0KCdzc20gcGFyYW1ldGVyIHByb3ZpZGVyIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBleHBlY3QoY2RrKFsnc3ludGgnLFxuICAgIGZ1bGxTdGFja05hbWUoJ21pc3Npbmctc3NtLXBhcmFtZXRlcicpLFxuICAgICctYycsICd0ZXN0OnNzbS1wYXJhbWV0ZXItbmFtZT0vZG9lcy9ub3QvZXhpc3QnLFxuICBdLCB7XG4gICAgYWxsb3dFcnJFeGl0OiB0cnVlLFxuICB9KSkucmVzb2x2ZXMudG9Db250YWluKCdTU00gcGFyYW1ldGVyIG5vdCBhdmFpbGFibGUgaW4gYWNjb3VudCcpO1xufSk7XG5cbmludGVnVGVzdCgnYXV0b21hdGljIG9yZGVyaW5nJywgYXN5bmMgKCkgPT4ge1xuICAvLyBEZXBsb3kgdGhlIGNvbnN1bWluZyBzdGFjayB3aGljaCB3aWxsIGluY2x1ZGUgdGhlIHByb2R1Y2luZyBzdGFja1xuICBhd2FpdCBjZGtEZXBsb3koJ29yZGVyLWNvbnN1bWluZycpO1xuXG4gIC8vIERlc3Ryb3kgdGhlIHByb3ZpZGluZyBzdGFjayB3aGljaCB3aWxsIGluY2x1ZGUgdGhlIGNvbnN1bWluZyBzdGFja1xuICBhd2FpdCBjZGtEZXN0cm95KCdvcmRlci1wcm92aWRpbmcnKTtcbn0pO1xuXG5pbnRlZ1Rlc3QoJ2NvbnRleHQgc2V0dGluZycsIGFzeW5jICgpID0+IHtcbiAgYXdhaXQgZnMud3JpdGVGaWxlKHBhdGguam9pbihJTlRFR19URVNUX0RJUiwgJ2Nkay5jb250ZXh0Lmpzb24nKSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgIGNvbnRleHRrZXk6ICd0aGlzIGlzIHRoZSBjb250ZXh0IHZhbHVlJyxcbiAgfSkpO1xuICB0cnkge1xuICAgIGF3YWl0IGV4cGVjdChjZGsoWydjb250ZXh0J10pKS5yZXNvbHZlcy50b0NvbnRhaW4oJ3RoaXMgaXMgdGhlIGNvbnRleHQgdmFsdWUnKTtcblxuICAgIC8vIFRlc3QgdGhhdCBkZWxldGluZyB0aGUgY29udGV4dGtleSB3b3Jrc1xuICAgIGF3YWl0IGNkayhbJ2NvbnRleHQnLCAnLS1yZXNldCcsICdjb250ZXh0a2V5J10pO1xuICAgIGF3YWl0IGV4cGVjdChjZGsoWydjb250ZXh0J10pKS5yZXNvbHZlcy5ub3QudG9Db250YWluKCd0aGlzIGlzIHRoZSBjb250ZXh0IHZhbHVlJyk7XG5cbiAgICAvLyBUZXN0IHRoYXQgZm9yY2VkIGRlbGV0ZSBvZiB0aGUgY29udGV4dCBrZXkgZG9lcyBub3QgdGhyb3dcbiAgICBhd2FpdCBjZGsoWydjb250ZXh0JywgJy1mJywgJy0tcmVzZXQnLCAnY29udGV4dGtleSddKTtcblxuICB9IGZpbmFsbHkge1xuICAgIGF3YWl0IGZzLnVubGluayhwYXRoLmpvaW4oSU5URUdfVEVTVF9ESVIsICdjZGsuY29udGV4dC5qc29uJykpO1xuICB9XG59KTtcblxuaW50ZWdUZXN0KCdkZXBsb3knLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHN0YWNrQXJuID0gYXdhaXQgY2RrRGVwbG95KCd0ZXN0LTInLCB7IGNhcHR1cmVTdGRlcnI6IGZhbHNlIH0pO1xuXG4gIC8vIHZlcmlmeSB0aGUgbnVtYmVyIG9mIHJlc291cmNlcyBpbiB0aGUgc3RhY2tcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbG91ZEZvcm1hdGlvbignZGVzY3JpYmVTdGFja1Jlc291cmNlcycsIHtcbiAgICBTdGFja05hbWU6IHN0YWNrQXJuLFxuICB9KTtcbiAgZXhwZWN0KHJlc3BvbnNlLlN0YWNrUmVzb3VyY2VzPy5sZW5ndGgpLnRvRXF1YWwoMik7XG59KTtcblxuaW50ZWdUZXN0KCdkZXBsb3kgYWxsJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBhcm5zID0gYXdhaXQgY2RrRGVwbG95KCd0ZXN0LSonLCB7IGNhcHR1cmVTdGRlcnI6IGZhbHNlIH0pO1xuXG4gIC8vIHZlcmlmeSB0aGF0IHdlIG9ubHkgZGVwbG95ZWQgYSBzaW5nbGUgc3RhY2sgKHRoZXJlJ3MgYSBzaW5nbGUgQVJOIGluIHRoZSBvdXRwdXQpXG4gIGV4cGVjdChhcm5zLnNwbGl0KCdcXG4nKS5sZW5ndGgpLnRvRXF1YWwoMik7XG59KTtcblxuaW50ZWdUZXN0KCduZXN0ZWQgc3RhY2sgd2l0aCBwYXJhbWV0ZXJzJywgYXN5bmMgKCkgPT4ge1xuLy8gU1RBQ0tfTkFNRV9QUkVGSVggaXMgdXNlZCBpbiBNeVRvcGljUGFyYW0gdG8gYWxsb3cgbXVsdGlwbGUgaW5zdGFuY2VzXG4vLyBvZiB0aGlzIHRlc3QgdG8gcnVuIGluIHBhcmFsbGVsLCBvdGhld2lzZSB0aGV5IHdpbGwgYXR0ZW1wdCB0byBjcmVhdGUgdGhlIHNhbWUgU05TIHRvcGljLlxuICBjb25zdCBzdGFja0FybiA9IGF3YWl0IGNka0RlcGxveSgnd2l0aC1uZXN0ZWQtc3RhY2stdXNpbmctcGFyYW1ldGVycycsIHtcbiAgICBvcHRpb25zOiBbJy0tcGFyYW1ldGVycycsICdNeVRvcGljUGFyYW09JHtTVEFDS19OQU1FX1BSRUZJWH1UaGVyZUlzTm9TcG9vbiddLFxuICAgIGNhcHR1cmVTdGRlcnI6IGZhbHNlLFxuICB9KTtcblxuICAvLyB2ZXJpZnkgdGhhdCB3ZSBvbmx5IGRlcGxveWVkIGEgc2luZ2xlIHN0YWNrICh0aGVyZSdzIGEgc2luZ2xlIEFSTiBpbiB0aGUgb3V0cHV0KVxuICBleHBlY3Qoc3RhY2tBcm4uc3BsaXQoJ1xcbicpLmxlbmd0aCkudG9FcXVhbCgxKTtcblxuICAvLyB2ZXJpZnkgdGhlIG51bWJlciBvZiByZXNvdXJjZXMgaW4gdGhlIHN0YWNrXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xvdWRGb3JtYXRpb24oJ2Rlc2NyaWJlU3RhY2tSZXNvdXJjZXMnLCB7XG4gICAgU3RhY2tOYW1lOiBzdGFja0FybixcbiAgfSk7XG4gIGV4cGVjdChyZXNwb25zZS5TdGFja1Jlc291cmNlcz8ubGVuZ3RoKS50b0VxdWFsKDEpO1xufSk7XG5cbmludGVnVGVzdCgnZGVwbG95IHdpdGhvdXQgZXhlY3V0ZScsIGFzeW5jICgpID0+IHtcbiAgY29uc3Qgc3RhY2tBcm4gPSBhd2FpdCBjZGtEZXBsb3koJ3Rlc3QtMicsIHtcbiAgICBvcHRpb25zOiBbJy0tbm8tZXhlY3V0ZSddLFxuICAgIGNhcHR1cmVTdGRlcnI6IGZhbHNlLFxuICB9KTtcbiAgLy8gdmVyaWZ5IHRoYXQgd2Ugb25seSBkZXBsb3llZCBhIHNpbmdsZSBzdGFjayAodGhlcmUncyBhIHNpbmdsZSBBUk4gaW4gdGhlIG91dHB1dClcbiAgZXhwZWN0KHN0YWNrQXJuLnNwbGl0KCdcXG4nKS5sZW5ndGgpLnRvRXF1YWwoMSk7XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbG91ZEZvcm1hdGlvbignZGVzY3JpYmVTdGFja3MnLCB7XG4gICAgU3RhY2tOYW1lOiBzdGFja0FybixcbiAgfSk7XG5cbiAgZXhwZWN0KHJlc3BvbnNlLlN0YWNrcz8uWzBdLlN0YWNrU3RhdHVzKS50b0VxdWFsKCdSRVZJRVdfSU5fUFJPR1JFU1MnKTtcbn0pO1xuXG5pbnRlZ1Rlc3QoJ3NlY3VyaXR5IHJlbGF0ZWQgY2hhbmdlcyB3aXRob3V0IGEgQ0xJIGFyZSBleHBlY3RlZCB0byBmYWlsJywgYXN5bmMgKCkgPT4ge1xuICAvLyByZWRpcmVjdCAvZGV2L251bGwgdG8gc3RkaW4sIHdoaWNoIG1lYW5zIHRoZXJlIHdpbGwgbm90IGJlIHR0eSBhdHRhY2hlZFxuICAvLyBzaW5jZSB0aGlzIHN0YWNrIGluY2x1ZGVzIHNlY3VyaXR5LXJlbGF0ZWQgY2hhbmdlcywgdGhlIGRlcGxveW1lbnQgc2hvdWxkXG4gIC8vIGltbWVkaWF0ZWx5IGZhaWwgYmVjYXVzZSB3ZSBjYW4ndCBjb25maXJtIHRoZSBjaGFuZ2VzXG4gIGNvbnN0IHN0YWNrTmFtZSA9ICdpYW0tdGVzdCc7XG4gIGF3YWl0IGV4cGVjdChjZGtEZXBsb3koc3RhY2tOYW1lLCB7XG4gICAgb3B0aW9uczogWyc8JywgJy9kZXYvbnVsbCddLCAvLyBINHgsIHRoaXMgb25seSB3b3JrcyBiZWNhdXNlIEkgaGFwcGVuIHRvIGtub3cgd2UgcGFzcyBzaGVsbDogdHJ1ZS5cbiAgICBuZXZlclJlcXVpcmVBcHByb3ZhbDogZmFsc2UsXG4gIH0pKS5yZWplY3RzLnRvVGhyb3coJ2V4aXRlZCB3aXRoIGVycm9yJyk7XG5cbiAgLy8gRW5zdXJlIHN0YWNrIHdhcyBub3QgZGVwbG95ZWRcbiAgYXdhaXQgZXhwZWN0KGNsb3VkRm9ybWF0aW9uKCdkZXNjcmliZVN0YWNrcycsIHtcbiAgICBTdGFja05hbWU6IGZ1bGxTdGFja05hbWUoc3RhY2tOYW1lKSxcbiAgfSkpLnJlamVjdHMudG9UaHJvdygnZG9lcyBub3QgZXhpc3QnKTtcbn0pO1xuXG5pbnRlZ1Rlc3QoJ2RlcGxveSB3aWxkY2FyZCB3aXRoIG91dHB1dHMnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IG91dHB1dHNGaWxlID0gcGF0aC5qb2luKElOVEVHX1RFU1RfRElSLCAnb3V0cHV0cycsICdvdXRwdXRzLmpzb24nKTtcbiAgYXdhaXQgZnMubWtkaXIocGF0aC5kaXJuYW1lKG91dHB1dHNGaWxlKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG5cbiAgYXdhaXQgY2RrRGVwbG95KFsnb3V0cHV0cy10ZXN0LSonXSwge1xuICAgIG9wdGlvbnM6IFsnLS1vdXRwdXRzLWZpbGUnLCBvdXRwdXRzRmlsZV0sXG4gIH0pO1xuXG4gIGNvbnN0IG91dHB1dHMgPSBKU09OLnBhcnNlKChhd2FpdCBmcy5yZWFkRmlsZShvdXRwdXRzRmlsZSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KSkudG9TdHJpbmcoKSk7XG4gIGV4cGVjdChvdXRwdXRzKS50b0VxdWFsKHtcbiAgICBbYCR7U1RBQ0tfTkFNRV9QUkVGSVh9LW91dHB1dHMtdGVzdC0xYF06IHtcbiAgICAgIFRvcGljTmFtZTogYCR7U1RBQ0tfTkFNRV9QUkVGSVh9LW91dHB1dHMtdGVzdC0xTXlUb3BpY2AsXG4gICAgfSxcbiAgICBbYCR7U1RBQ0tfTkFNRV9QUkVGSVh9LW91dHB1dHMtdGVzdC0yYF06IHtcbiAgICAgIFRvcGljTmFtZTogYCR7U1RBQ0tfTkFNRV9QUkVGSVh9LW91dHB1dHMtdGVzdC0yTXlPdGhlclRvcGljYCxcbiAgICB9LFxuICB9KTtcbn0pO1xuXG5pbnRlZ1Rlc3QoJ2RlcGxveSB3aXRoIHBhcmFtZXRlcnMnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHN0YWNrQXJuID0gYXdhaXQgY2RrRGVwbG95KCdwYXJhbS10ZXN0LTEnLCB7XG4gICAgb3B0aW9uczogW1xuICAgICAgJy0tcGFyYW1ldGVycycsIGBUb3BpY05hbWVQYXJhbT0ke1NUQUNLX05BTUVfUFJFRklYfWJhemluZ2FgLFxuICAgIF0sXG4gICAgY2FwdHVyZVN0ZGVycjogZmFsc2UsXG4gIH0pO1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xvdWRGb3JtYXRpb24oJ2Rlc2NyaWJlU3RhY2tzJywge1xuICAgIFN0YWNrTmFtZTogc3RhY2tBcm4sXG4gIH0pO1xuXG4gIGV4cGVjdChyZXNwb25zZS5TdGFja3M/LlswXS5QYXJhbWV0ZXJzKS50b0VxdWFsKFtcbiAgICB7XG4gICAgICBQYXJhbWV0ZXJLZXk6ICdUb3BpY05hbWVQYXJhbScsXG4gICAgICBQYXJhbWV0ZXJWYWx1ZTogYCR7U1RBQ0tfTkFNRV9QUkVGSVh9YmF6aW5nYWAsXG4gICAgfSxcbiAgXSk7XG59KTtcblxuaW50ZWdUZXN0KCdkZXBsb3kgd2l0aCB3aWxkY2FyZCBhbmQgcGFyYW1ldGVycycsIGFzeW5jICgpID0+IHtcbiAgYXdhaXQgY2RrRGVwbG95KCdwYXJhbS10ZXN0LSonLCB7XG4gICAgb3B0aW9uczogW1xuICAgICAgJy0tcGFyYW1ldGVycycsIGAke1NUQUNLX05BTUVfUFJFRklYfS1wYXJhbS10ZXN0LTE6VG9waWNOYW1lUGFyYW09JHtTVEFDS19OQU1FX1BSRUZJWH1iYXppbmdhYCxcbiAgICAgICctLXBhcmFtZXRlcnMnLCBgJHtTVEFDS19OQU1FX1BSRUZJWH0tcGFyYW0tdGVzdC0yOk90aGVyVG9waWNOYW1lUGFyYW09JHtTVEFDS19OQU1FX1BSRUZJWH1UaGF0c015U3BvdGAsXG4gICAgICAnLS1wYXJhbWV0ZXJzJywgYCR7U1RBQ0tfTkFNRV9QUkVGSVh9LXBhcmFtLXRlc3QtMzpEaXNwbGF5TmFtZVBhcmFtPSR7U1RBQ0tfTkFNRV9QUkVGSVh9SGV5VGhlcmVgLFxuICAgICAgJy0tcGFyYW1ldGVycycsIGAke1NUQUNLX05BTUVfUFJFRklYfS1wYXJhbS10ZXN0LTM6T3RoZXJEaXNwbGF5TmFtZVBhcmFtPSR7U1RBQ0tfTkFNRV9QUkVGSVh9QW5vdGhlck9uZWAsXG4gICAgXSxcbiAgfSk7XG59KTtcblxuaW50ZWdUZXN0KCdkZXBsb3kgd2l0aCBwYXJhbWV0ZXJzIG11bHRpJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCBwYXJhbVZhbDEgPSBgJHtTVEFDS19OQU1FX1BSRUZJWH1iYXppbmdhYDtcbiAgY29uc3QgcGFyYW1WYWwyID0gYCR7U1RBQ0tfTkFNRV9QUkVGSVh9PWphZ3NoZW1hc2hgO1xuXG4gIGNvbnN0IHN0YWNrQXJuID0gYXdhaXQgY2RrRGVwbG95KCdwYXJhbS10ZXN0LTMnLCB7XG4gICAgb3B0aW9uczogW1xuICAgICAgJy0tcGFyYW1ldGVycycsIGBEaXNwbGF5TmFtZVBhcmFtPSR7cGFyYW1WYWwxfWAsXG4gICAgICAnLS1wYXJhbWV0ZXJzJywgYE90aGVyRGlzcGxheU5hbWVQYXJhbT0ke3BhcmFtVmFsMn1gLFxuICAgIF0sXG4gICAgY2FwdHVyZVN0ZGVycjogZmFsc2UsXG4gIH0pO1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xvdWRGb3JtYXRpb24oJ2Rlc2NyaWJlU3RhY2tzJywge1xuICAgIFN0YWNrTmFtZTogc3RhY2tBcm4sXG4gIH0pO1xuXG4gIGV4cGVjdChyZXNwb25zZS5TdGFja3M/LlswXS5QYXJhbWV0ZXJzKS50b0VxdWFsKFtcbiAgICB7XG4gICAgICBQYXJhbWV0ZXJLZXk6ICdEaXNwbGF5TmFtZVBhcmFtJyxcbiAgICAgIFBhcmFtZXRlclZhbHVlOiBwYXJhbVZhbDEsXG4gICAgfSxcbiAgICB7XG4gICAgICBQYXJhbWV0ZXJLZXk6ICdPdGhlckRpc3BsYXlOYW1lUGFyYW0nLFxuICAgICAgUGFyYW1ldGVyVmFsdWU6IHBhcmFtVmFsMixcbiAgICB9LFxuICBdKTtcbn0pO1xuXG5pbnRlZ1Rlc3QoJ2RlcGxveSB3aXRoIG5vdGlmaWNhdGlvbiBBUk4nLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IHRvcGljTmFtZSA9IGAke1NUQUNLX05BTUVfUFJFRklYfS10ZXN0LXRvcGljYDtcblxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNucygnY3JlYXRlVG9waWMnLCB7IE5hbWU6IHRvcGljTmFtZSB9KTtcbiAgY29uc3QgdG9waWNBcm4gPSByZXNwb25zZS5Ub3BpY0FybiE7XG4gIHRyeSB7XG4gICAgYXdhaXQgY2RrRGVwbG95KCd0ZXN0LTInLCB7XG4gICAgICBvcHRpb25zOiBbJy0tbm90aWZpY2F0aW9uLWFybnMnLCB0b3BpY0Fybl0sXG4gICAgfSk7XG5cbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgc3RhY2sgd2UgZGVwbG95ZWQgaGFzIG91ciBub3RpZmljYXRpb24gQVJOXG4gICAgY29uc3QgZGVzY3JpYmVSZXNwb25zZSA9IGF3YWl0IGNsb3VkRm9ybWF0aW9uKCdkZXNjcmliZVN0YWNrcycsIHtcbiAgICAgIFN0YWNrTmFtZTogZnVsbFN0YWNrTmFtZSgndGVzdC0yJyksXG4gICAgfSk7XG4gICAgZXhwZWN0KGRlc2NyaWJlUmVzcG9uc2UuU3RhY2tzPy5bMF0uTm90aWZpY2F0aW9uQVJOcykudG9FcXVhbChbdG9waWNBcm5dKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhd2FpdCBzbnMoJ2RlbGV0ZVRvcGljJywge1xuICAgICAgVG9waWNBcm46IHRvcGljQXJuLFxuICAgIH0pO1xuICB9XG59KTtcblxuaW50ZWdUZXN0KCdkZXBsb3kgd2l0aCByb2xlJywgYXN5bmMgKCkgPT4ge1xuICBjb25zdCByb2xlTmFtZSA9IGAke1NUQUNLX05BTUVfUFJFRklYfS10ZXN0LXJvbGVgO1xuXG4gIGF3YWl0IGRlbGV0ZVJvbGUoKTtcblxuICBjb25zdCBjcmVhdGVSZXNwb25zZSA9IGF3YWl0IGlhbSgnY3JlYXRlUm9sZScsIHtcbiAgICBSb2xlTmFtZTogcm9sZU5hbWUsXG4gICAgQXNzdW1lUm9sZVBvbGljeURvY3VtZW50OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBWZXJzaW9uOiAnMjAxMi0xMC0xNycsXG4gICAgICBTdGF0ZW1lbnQ6IFt7XG4gICAgICAgIEFjdGlvbjogJ3N0czpBc3N1bWVSb2xlJyxcbiAgICAgICAgUHJpbmNpcGFsOiB7IFNlcnZpY2U6ICdjbG91ZGZvcm1hdGlvbi5hbWF6b25hd3MuY29tJyB9LFxuICAgICAgICBFZmZlY3Q6ICdBbGxvdycsXG4gICAgICB9LCB7XG4gICAgICAgIEFjdGlvbjogJ3N0czpBc3N1bWVSb2xlJyxcbiAgICAgICAgUHJpbmNpcGFsOiB7IEFXUzogKGF3YWl0IHN0cygnZ2V0Q2FsbGVySWRlbnRpdHknLCB7fSkpLkFybiB9LFxuICAgICAgICBFZmZlY3Q6ICdBbGxvdycsXG4gICAgICB9XSxcbiAgICB9KSxcbiAgfSk7XG4gIGNvbnN0IHJvbGVBcm4gPSBjcmVhdGVSZXNwb25zZS5Sb2xlLkFybjtcbiAgdHJ5IHtcbiAgICBhd2FpdCBpYW0oJ3B1dFJvbGVQb2xpY3knLCB7XG4gICAgICBSb2xlTmFtZTogcm9sZU5hbWUsXG4gICAgICBQb2xpY3lOYW1lOiAnRGVmYXVsdFBvbGljeScsXG4gICAgICBQb2xpY3lEb2N1bWVudDogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBWZXJzaW9uOiAnMjAxMi0xMC0xNycsXG4gICAgICAgIFN0YXRlbWVudDogW3tcbiAgICAgICAgICBBY3Rpb246ICcqJyxcbiAgICAgICAgICBSZXNvdXJjZTogJyonLFxuICAgICAgICAgIEVmZmVjdDogJ0FsbG93JyxcbiAgICAgICAgfV0sXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGF3YWl0IHJldHJ5KCdUcnlpbmcgdG8gYXNzdW1lIGZyZXNoIHJvbGUnLCByZXRyeS5mb3JTZWNvbmRzKDMwMCksIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHN0cygnYXNzdW1lUm9sZScsIHtcbiAgICAgICAgUm9sZUFybjogcm9sZUFybixcbiAgICAgICAgUm9sZVNlc3Npb25OYW1lOiAndGVzdGluZycsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIEluIHByaW5jaXBsZSwgdGhlIHJvbGUgaGFzIHJlcGxpY2F0ZWQgZnJvbSAndXMtZWFzdC0xJyB0byB3aGVyZXZlciB3ZSdyZSB0ZXN0aW5nLlxuICAgIC8vIEdpdmUgaXQgYSBsaXR0bGUgbW9yZSBzbGVlcCB0byBtYWtlIHN1cmUgQ2xvdWRGb3JtYXRpb24gaXMgbm90IGhpdHRpbmcgYSBib3hcbiAgICAvLyB0aGF0IGRvZXNuJ3QgaGF2ZSBpdCB5ZXQuXG4gICAgYXdhaXQgc2xlZXAoNTAwMCk7XG5cbiAgICBhd2FpdCBjZGtEZXBsb3koJ3Rlc3QtMicsIHtcbiAgICAgIG9wdGlvbnM6IFsnLS1yb2xlLWFybicsIHJvbGVBcm5dLFxuICAgIH0pO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgZGVsZXRlIHRoZSBzdGFjayBhZ2FpbiBiZWZvcmUgd2UgZGVsZXRlIHRoZSByb2xlLlxuICAgIC8vXG4gICAgLy8gU2luY2Ugcm9sZXMgYXJlIHN0aWNreSwgaWYgd2UgZGVsZXRlIHRoZSByb2xlIGJlZm9yZSB0aGUgc3RhY2ssIHN1YnNlcXVlbnQgRGVsZXRlU3RhY2tcbiAgICAvLyBvcGVyYXRpb25zIHdpbGwgZmFpbCB3aGVuIENsb3VkRm9ybWF0aW9uIHRyaWVzIHRvIGFzc3VtZSB0aGUgcm9sZSB0aGF0J3MgYWxyZWFkeSBnb25lLlxuICAgIGF3YWl0IGNka0Rlc3Ryb3koJ3Rlc3QtMicpO1xuXG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZGVsZXRlUm9sZSgpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gZGVsZXRlUm9sZSgpIHtcbiAgICB0cnkge1xuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBmb3JpblxuICAgICAgZm9yIChjb25zdCBwb2xpY3lOYW1lIG9mIChhd2FpdCBpYW0oJ2xpc3RSb2xlUG9saWNpZXMnLCB7IFJvbGVOYW1lOiByb2xlTmFtZSB9KSkuUG9saWN5TmFtZXMpIHtcbiAgICAgICAgYXdhaXQgaWFtKCdkZWxldGVSb2xlUG9saWN5Jywge1xuICAgICAgICAgIFJvbGVOYW1lOiByb2xlTmFtZSxcbiAgICAgICAgICBQb2xpY3lOYW1lOiBwb2xpY3lOYW1lLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IGlhbSgnZGVsZXRlUm9sZScsIHsgUm9sZU5hbWU6IHJvbGVOYW1lIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm1lc3NhZ2UuaW5kZXhPZignY2Fubm90IGJlIGZvdW5kJykgPiAtMSkgeyByZXR1cm47IH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG59KTtcblxuaW50ZWdUZXN0KCdjZGsgZGlmZicsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgZGlmZjEgPSBhd2FpdCBjZGsoWydkaWZmJywgZnVsbFN0YWNrTmFtZSgndGVzdC0xJyldKTtcbiAgZXhwZWN0KGRpZmYxKS50b0NvbnRhaW4oJ0FXUzo6U05TOjpUb3BpYycpO1xuXG4gIGNvbnN0IGRpZmYyID0gYXdhaXQgY2RrKFsnZGlmZicsIGZ1bGxTdGFja05hbWUoJ3Rlc3QtMicpXSk7XG4gIGV4cGVjdChkaWZmMikudG9Db250YWluKCdBV1M6OlNOUzo6VG9waWMnKTtcblxuICAvLyBXZSBjYW4gbWFrZSBpdCBmYWlsIGJ5IHBhc3NpbmcgLS1mYWlsXG4gIGF3YWl0IGV4cGVjdChjZGsoWydkaWZmJywgJy0tZmFpbCcsIGZ1bGxTdGFja05hbWUoJ3Rlc3QtMScpXSkpXG4gICAgLnJlamVjdHMudG9UaHJvdygnZXhpdGVkIHdpdGggZXJyb3InKTtcbn0pO1xuXG5pbnRlZ1Rlc3QoJ2RlcGxveSBzdGFjayB3aXRoIGRvY2tlciBhc3NldCcsIGFzeW5jICgpID0+IHtcbiAgYXdhaXQgY2RrRGVwbG95KCdkb2NrZXInKTtcbn0pO1xuXG5pbnRlZ1Rlc3QoJ2RlcGxveSBhbmQgdGVzdCBzdGFjayB3aXRoIGxhbWJkYSBhc3NldCcsIGFzeW5jICgpID0+IHtcbiAgY29uc3Qgc3RhY2tBcm4gPSBhd2FpdCBjZGtEZXBsb3koJ2xhbWJkYScsIHsgY2FwdHVyZVN0ZGVycjogZmFsc2UgfSk7XG5cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbG91ZEZvcm1hdGlvbignZGVzY3JpYmVTdGFja3MnLCB7XG4gICAgU3RhY2tOYW1lOiBzdGFja0FybixcbiAgfSk7XG4gIGNvbnN0IGxhbWJkYUFybiA9IHJlc3BvbnNlLlN0YWNrcz8uWzBdLk91dHB1dHM/LlswXS5PdXRwdXRWYWx1ZTtcbiAgaWYgKGxhbWJkYUFybiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdGFjayBkaWQgbm90IGhhdmUgZXhwZWN0ZWQgTGFtYmRhIEFSTiBvdXRwdXQnKTtcbiAgfVxuXG4gIGNvbnN0IG91dHB1dCA9IGF3YWl0IGxhbWJkYSgnaW52b2tlJywge1xuICAgIEZ1bmN0aW9uTmFtZTogbGFtYmRhQXJuLFxuICB9KTtcblxuICBleHBlY3QoSlNPTi5zdHJpbmdpZnkob3V0cHV0LlBheWxvYWQpKS50b0NvbnRhaW4oJ2RlYXIgYXNzZXQnKTtcbn0pO1xuXG5pbnRlZ1Rlc3QoJ2NkayBscycsIGFzeW5jICgpID0+IHtcbiAgY29uc3QgbGlzdGluZyA9IGF3YWl0IGNkayhbJ2xzJ10sIHsgY2FwdHVyZVN0ZGVycjogZmFsc2UgfSk7XG5cbiAgY29uc3QgZXhwZWN0ZWRTdGFja3MgPSBbXG4gICAgJ2NvbmRpdGlvbmFsLXJlc291cmNlJyxcbiAgICAnZG9ja2VyJyxcbiAgICAnZG9ja2VyLXdpdGgtY3VzdG9tLWZpbGUnLFxuICAgICdmYWlsZWQnLFxuICAgICdpYW0tdGVzdCcsXG4gICAgJ2xhbWJkYScsXG4gICAgJ21pc3Npbmctc3NtLXBhcmFtZXRlcicsXG4gICAgJ29yZGVyLXByb3ZpZGluZycsXG4gICAgJ291dHB1dHMtdGVzdC0xJyxcbiAgICAnb3V0cHV0cy10ZXN0LTInLFxuICAgICdwYXJhbS10ZXN0LTEnLFxuICAgICdwYXJhbS10ZXN0LTInLFxuICAgICdwYXJhbS10ZXN0LTMnLFxuICAgICd0ZXJtaW5hdGlvbi1wcm90ZWN0aW9uJyxcbiAgICAndGVzdC0xJyxcbiAgICAndGVzdC0yJyxcbiAgICAnd2l0aC1uZXN0ZWQtc3RhY2snLFxuICAgICd3aXRoLW5lc3RlZC1zdGFjay11c2luZy1wYXJhbWV0ZXJzJyxcbiAgICAnb3JkZXItY29uc3VtaW5nJyxcbiAgXTtcblxuICBmb3IgKGNvbnN0IHN0YWNrIG9mIGV4cGVjdGVkU3RhY2tzKSB7XG4gICAgZXhwZWN0KGxpc3RpbmcpLnRvQ29udGFpbihmdWxsU3RhY2tOYW1lKHN0YWNrKSk7XG4gIH1cbn0pO1xuXG5pbnRlZ1Rlc3QoJ2RlcGxveSBzdGFjayB3aXRob3V0IHJlc291cmNlJywgYXN5bmMgKCkgPT4ge1xuICAvLyBEZXBsb3kgdGhlIHN0YWNrIHdpdGhvdXQgcmVzb3VyY2VzXG4gIGF3YWl0IGNka0RlcGxveSgnY29uZGl0aW9uYWwtcmVzb3VyY2UnLCB7IG1vZEVudjogeyBOT19SRVNPVVJDRTogJ1RSVUUnIH19KTtcblxuICAvLyBUaGlzIHNob3VsZCBoYXZlIHN1Y2NlZWRlZCBidXQgbm90IGRlcGxveWVkIHRoZSBzdGFjay5cbiAgYXdhaXQgZXhwZWN0KGNsb3VkRm9ybWF0aW9uKCdkZXNjcmliZVN0YWNrcycsIHsgU3RhY2tOYW1lOiBmdWxsU3RhY2tOYW1lKCdjb25kaXRpb25hbC1yZXNvdXJjZScpIH0pKVxuICAgIC5yZWplY3RzLnRvVGhyb3coJ2NvbmRpdGlvbmFsLXJlc291cmNlIGRvZXMgbm90IGV4aXN0Jyk7XG5cbiAgLy8gRGVwbG95IHRoZSBzdGFjayB3aXRoIHJlc291cmNlc1xuICBhd2FpdCBjZGtEZXBsb3koJ2NvbmRpdGlvbmFsLXJlc291cmNlJyk7XG5cbiAgLy8gVGhlbiBhZ2FpbiBXSVRIT1VUIHJlc291cmNlcyAodGhpcyBzaG91bGQgZGVzdHJveSB0aGUgc3RhY2spXG4gIGF3YWl0IGNka0RlcGxveSgnY29uZGl0aW9uYWwtcmVzb3VyY2UnLCB7IG1vZEVudjogeyBOT19SRVNPVVJDRTogJ1RSVUUnIH0gfSk7XG5cbiAgYXdhaXQgZXhwZWN0KGNsb3VkRm9ybWF0aW9uKCdkZXNjcmliZVN0YWNrcycsIHsgU3RhY2tOYW1lOiBmdWxsU3RhY2tOYW1lKCdjb25kaXRpb25hbC1yZXNvdXJjZScpIH0pKVxuICAgIC5yZWplY3RzLnRvVGhyb3coJ2NvbmRpdGlvbmFsLXJlc291cmNlIGRvZXMgbm90IGV4aXN0Jyk7XG59KTtcblxuaW50ZWdUZXN0KCdJQU0gZGlmZicsIGFzeW5jICgpID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgY2RrKFsnZGlmZicsIGZ1bGxTdGFja05hbWUoJ2lhbS10ZXN0JyldKTtcblxuICAvLyBSb3VnaGx5IGNoZWNrIGZvciBhIHRhYmxlIGxpa2UgdGhpczpcbiAgLy9cbiAgLy8g4pSM4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSALeKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAvLyDilIIgICDilIIgUmVzb3VyY2UgICAgICAgIOKUgiBFZmZlY3Qg4pSCIEFjdGlvbiAgICAgICAgIOKUgiBQcmluY2lwYWwgICAgICAgICAgICAgICAgICAgICDilIIgQ29uZGl0aW9uIOKUglxuICAvLyDilJzilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgLy8g4pSCICsg4pSCICR7U29tZVJvbGUuQXJufSDilIIgQWxsb3cgIOKUgiBzdHM6QXNzdW1lUm9sZSDilIIgU2VydmljZTplYzIuYW1hem9uYXdzLmNvbSAgICAg4pSCICAgICAgICAgICDilIJcbiAgLy8g4pSU4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cbiAgZXhwZWN0KG91dHB1dCkudG9Db250YWluKCcke1NvbWVSb2xlLkFybn0nKTtcbiAgZXhwZWN0KG91dHB1dCkudG9Db250YWluKCdzdHM6QXNzdW1lUm9sZScpO1xuICBleHBlY3Qob3V0cHV0KS50b0NvbnRhaW4oJ2VjMi5hbWF6b25hd3MuY29tJyk7XG59KTtcblxuaW50ZWdUZXN0KCdmYXN0IGRlcGxveScsIGFzeW5jICgpID0+IHtcbiAgLy8gd2UgYXJlIHVzaW5nIGEgc3RhY2sgd2l0aCBhIG5lc3RlZCBzdGFjayBiZWNhdXNlIENGTiB3aWxsIGFsd2F5cyBhdHRlbXB0IHRvXG4gIC8vIHVwZGF0ZSBhIG5lc3RlZCBzdGFjaywgd2hpY2ggd2lsbCBhbGxvdyB1cyB0byB2ZXJpZnkgdGhhdCB1cGRhdGVzIGFyZSBhY3R1YWxseVxuICAvLyBza2lwcGVkIHVubGVzcyAtLWZvcmNlIGlzIHNwZWNpZmllZC5cbiAgY29uc3Qgc3RhY2tBcm4gPSBhd2FpdCBjZGtEZXBsb3koJ3dpdGgtbmVzdGVkLXN0YWNrJywgeyBjYXB0dXJlU3RkZXJyOiBmYWxzZSB9KTtcbiAgY29uc3QgY2hhbmdlU2V0MSA9IGF3YWl0IGdldExhdGVzdENoYW5nZVNldCgpO1xuXG4gIC8vIERlcGxveSB0aGUgc2FtZSBzdGFjayBhZ2FpbiwgdGhlcmUgc2hvdWxkIGJlIG5vIG5ldyBjaGFuZ2Ugc2V0IGNyZWF0ZWRcbiAgYXdhaXQgY2RrRGVwbG95KCd3aXRoLW5lc3RlZC1zdGFjaycpO1xuICBjb25zdCBjaGFuZ2VTZXQyID0gYXdhaXQgZ2V0TGF0ZXN0Q2hhbmdlU2V0KCk7XG4gIGV4cGVjdChjaGFuZ2VTZXQyLkNoYW5nZVNldElkKS50b0VxdWFsKGNoYW5nZVNldDEuQ2hhbmdlU2V0SWQpO1xuXG4gIC8vIERlcGxveSB0aGUgc3RhY2sgYWdhaW4gd2l0aCAtLWZvcmNlLCBub3cgd2Ugc2hvdWxkIGNyZWF0ZSBhIGNoYW5nZXNldFxuICBhd2FpdCBjZGtEZXBsb3koJ3dpdGgtbmVzdGVkLXN0YWNrJywgeyBvcHRpb25zOiBbJy0tZm9yY2UnXSB9KTtcbiAgY29uc3QgY2hhbmdlU2V0MyA9IGF3YWl0IGdldExhdGVzdENoYW5nZVNldCgpO1xuICBleHBlY3QoY2hhbmdlU2V0My5DaGFuZ2VTZXRJZCkubm90LnRvRXF1YWwoY2hhbmdlU2V0Mi5DaGFuZ2VTZXRJZCk7XG5cbiAgLy8gRGVwbG95IHRoZSBzdGFjayBhZ2FpbiB3aXRoIHRhZ3MsIGV4cGVjdGVkIHRvIGNyZWF0ZSBhIG5ldyBjaGFuZ2VzZXRcbiAgLy8gZXZlbiB0aG91Z2ggdGhlIHJlc291cmNlcyBkaWRuJ3QgY2hhbmdlLlxuICBhd2FpdCBjZGtEZXBsb3koJ3dpdGgtbmVzdGVkLXN0YWNrJywgeyBvcHRpb25zOiBbJy0tdGFncycsICdrZXk9dmFsdWUnXSB9KTtcbiAgY29uc3QgY2hhbmdlU2V0NCA9IGF3YWl0IGdldExhdGVzdENoYW5nZVNldCgpO1xuICBleHBlY3QoY2hhbmdlU2V0NC5DaGFuZ2VTZXRJZCkubm90LnRvRXF1YWwoY2hhbmdlU2V0My5DaGFuZ2VTZXRJZCk7XG5cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0TGF0ZXN0Q2hhbmdlU2V0KCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xvdWRGb3JtYXRpb24oJ2Rlc2NyaWJlU3RhY2tzJywgeyBTdGFja05hbWU6IHN0YWNrQXJuIH0pO1xuICAgIGlmICghcmVzcG9uc2UuU3RhY2tzPy5bMF0pIHsgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IGdldCBhIENoYW5nZVNldCBhdCBhbGwnKTsgfVxuICAgIGxvZyhgRm91bmQgQ2hhbmdlIFNldCAke3Jlc3BvbnNlLlN0YWNrcz8uWzBdLkNoYW5nZVNldElkfWApO1xuICAgIHJldHVybiByZXNwb25zZS5TdGFja3M/LlswXTtcbiAgfVxufSk7XG5cbmludGVnVGVzdCgnZmFpbGVkIGRlcGxveSBkb2VzIG5vdCBoYW5nJywgYXN5bmMgKCkgPT4ge1xuICAvLyB0aGlzIHdpbGwgaGFuZyBpZiB3ZSBpbnRyb2R1Y2UgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy82NDAzIGFnYWluLlxuICBhd2FpdCBleHBlY3QoY2RrRGVwbG95KCdmYWlsZWQnKSkucmVqZWN0cy50b1Rocm93KCdleGl0ZWQgd2l0aCBlcnJvcicpO1xufSk7XG5cbmludGVnVGVzdCgnY2FuIHN0aWxsIGxvYWQgb2xkIGFzc2VtYmxpZXMnLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGN4QXNtRGlyID0gIHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nkay1pbnRlZy1jeCcpO1xuXG4gIGNvbnN0IHRlc3RBc3NlbWJsaWVzRGlyZWN0b3J5ID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ2Nsb3VkLWFzc2VtYmxpZXMnKTtcbiAgZm9yIChjb25zdCBhc21kaXIgb2YgYXdhaXQgbGlzdENoaWxkRGlycyh0ZXN0QXNzZW1ibGllc0RpcmVjdG9yeSkpIHtcbiAgICBsb2coYEFTU0VNQkxZICR7YXNtZGlyfWApO1xuICAgIGF3YWl0IGNsb25lRGlyZWN0b3J5KGFzbWRpciwgY3hBc21EaXIpO1xuXG4gICAgLy8gU29tZSBmaWxlcyBpbiB0aGUgYXNtIGRpcmVjdG9yeSB0aGF0IGhhdmUgYSAuanMgZXh0ZW5zaW9uIGFyZVxuICAgIC8vIGFjdHVhbGx5IHRyZWF0ZWQgYXMgdGVtcGxhdGVzLiBFdmFsdWF0ZSB0aGVtIHVzaW5nIE5vZGVKUy5cbiAgICBjb25zdCB0ZW1wbGF0ZXMgPSBhd2FpdCBsaXN0Q2hpbGRyZW4oY3hBc21EaXIsIGZ1bGxQYXRoID0+IFByb21pc2UucmVzb2x2ZShmdWxsUGF0aC5lbmRzV2l0aCgnLmpzJykpKTtcbiAgICBmb3IgKGNvbnN0IHRlbXBsYXRlIG9mIHRlbXBsYXRlcykge1xuICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRlbXBsYXRlLnJlcGxhY2UoLy5qcyQvLCAnJyk7XG4gICAgICBhd2FpdCBzaGVsbChbcHJvY2Vzcy5leGVjUGF0aCwgdGVtcGxhdGUsICc+JywgdGFyZ2V0TmFtZV0sIHtcbiAgICAgICAgY3dkOiBjeEFzbURpcixcbiAgICAgICAgbW9kRW52OiB7XG4gICAgICAgICAgVEVTVF9BQ0NPVU5UOiAoYXdhaXQgdGVzdEVudigpKS5hY2NvdW50LFxuICAgICAgICAgIFRFU1RfUkVHSU9OOiAoYXdhaXQgdGVzdEVudigpKS5yZWdpb24sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhpcyBkaXJlY3RvcnkgYXMgYSBDbG91ZCBBc3NlbWJseVxuICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGNkayhbXG4gICAgICAnLS1hcHAnLCBjeEFzbURpcixcbiAgICAgICctdicsXG4gICAgICAnc3ludGgnXSk7XG5cbiAgICAvLyBBc3NlcnQgdGhhdCB0aGVyZSB3YXMgbm8gcHJvdmlkZXJFcnJvciBpbiBDREsncyBzdGRlcnJcbiAgICAvLyBCZWNhdXNlIHdlIHJlbHkgb24gdGhlIGFwcC9mcmFtZXdvcmsgdG8gYWN0dWFsbHkgZXJyb3IgaW4gY2FzZSB0aGVcbiAgICAvLyBwcm92aWRlciBmYWlscywgd2UgaW5zcGVjdCB0aGUgbG9ncyBoZXJlLlxuICAgIGV4cGVjdChvdXRwdXQpLm5vdC50b0NvbnRhaW4oJyRwcm92aWRlckVycm9yJyk7XG4gIH1cbn0pO1xuXG5pbnRlZ1Rlc3QoJ2dlbmVyYXRpbmcgYW5kIGxvYWRpbmcgYXNzZW1ibHknLCBhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGFzbU91dHB1dERpciA9IHBhdGguam9pbihvcy50bXBkaXIoKSwgJ2Nkay1pbnRlZy1hc20nKTtcbiAgYXdhaXQgc2hlbGwoWydybScsICctcmYnLCBhc21PdXRwdXREaXJdKTtcblxuICAvLyBNYWtlIHN1cmUgb3VyIGZpeHR1cmUgZGlyZWN0b3J5IGlzIGNsZWFuXG4gIGF3YWl0IHByZXBhcmVBcHBGaXh0dXJlKCk7XG5cbiAgLy8gU3ludGhlc2l6ZSBhIENsb3VkIEFzc2VtYmx5IHRvdGhlIGRlZmF1bHQgZGlyZWN0b3J5IChjZGsub3V0KSBhbmQgYSBzcGVjaWZpYyBkaXJlY3RvcnkuXG4gIGF3YWl0IGNkayhbJ3N5bnRoJ10pO1xuICBhd2FpdCBjZGsoWydzeW50aCcsICctLW91dHB1dCcsIGFzbU91dHB1dERpcl0pO1xuXG4gIC8vIGNkay5vdXQgaW4gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGFuZCB0aGUgaW5kaWNhdGVkIC0tb3V0cHV0IHNob3VsZCBiZSB0aGUgc2FtZVxuICBhd2FpdCBzaGVsbChbJ2RpZmYnLCAnY2RrLm91dCcsIGFzbU91dHB1dERpcl0sIHtcbiAgICBjd2Q6IElOVEVHX1RFU1RfRElSLFxuICB9KTtcblxuICAvLyBDaGVjayB0aGF0IHdlIGNhbiAnbHMnIHRoZSBzeW50aGVzaXplZCBhc20uXG4gIC8vIENoYW5nZSB0byBzb21lIHJhbmRvbSBkaXJlY3RvcnkgdG8gbWFrZSBzdXJlIHdlJ3JlIG5vdCBhY2NpZGVudGFsbHkgbG9hZGluZyBjZGsuanNvblxuICBjb25zdCBsaXN0ID0gYXdhaXQgY2RrKFsnLS1hcHAnLCBhc21PdXRwdXREaXIsICdscyddLCB7IGN3ZDogb3MudG1wZGlyKCkgfSk7XG4gIC8vIFNhbWUgc3RhY2tzIHdlIGtub3cgYXJlIGluIHRoZSBhcHBcbiAgZXhwZWN0KGxpc3QpLnRvQ29udGFpbihgJHtTVEFDS19OQU1FX1BSRUZJWH0tbGFtYmRhYCk7XG4gIGV4cGVjdChsaXN0KS50b0NvbnRhaW4oYCR7U1RBQ0tfTkFNRV9QUkVGSVh9LXRlc3QtMWApO1xuICBleHBlY3QobGlzdCkudG9Db250YWluKGAke1NUQUNLX05BTUVfUFJFRklYfS10ZXN0LTJgKTtcblxuICAvLyBDaGVjayB0aGF0IHdlIGNhbiB1c2UgJy4nIGFuZCBqdXN0IHN5bnRoICx0aGUgZ2VuZXJhdGVkIGFzbVxuICBjb25zdCBzdGFja1RlbXBsYXRlID0gYXdhaXQgY2RrKFsnLS1hcHAnLCAnLicsICdzeW50aCcsIGZ1bGxTdGFja05hbWUoJ3Rlc3QtMicpXSwge1xuICAgIGN3ZDogYXNtT3V0cHV0RGlyLFxuICB9KTtcbiAgZXhwZWN0KHN0YWNrVGVtcGxhdGUpLnRvQ29udGFpbigndG9waWMxNTJEODRBMzcnKTtcblxuICAvLyBEZXBsb3kgYSBMYW1iZGEgZnJvbSB0aGUgY29waWVkIGFzbVxuICBhd2FpdCBjZGtEZXBsb3koJ2xhbWJkYScsIHsgb3B0aW9uczogWyctYScsICcuJ10sIGN3ZDogYXNtT3V0cHV0RGlyIH0pO1xuXG4gIC8vIFJlbW92ZSB0aGUgb3JpZ2luYWwgY3VzdG9tIGRvY2tlciBmaWxlIHRoYXQgd2FzIHVzZWQgZHVyaW5nIHN5bnRoLlxuICAvLyB0aGlzIHZlcmlmaWVzIHRoYXQgdGhlIGFzc2VtbHkgaGFzIGEgY29weSBvZiBpdCBhbmQgdGhhdCB0aGUgbWFuaWZlc3QgdXNlc1xuICAvLyByZWxhdGl2ZSBwYXRocyB0byByZWZlcmVuY2UgdG8gaXQuXG4gIGF3YWl0IGZzLnVubGluayhwYXRoLmpvaW4oSU5URUdfVEVTVF9ESVIsICdkb2NrZXInLCAnRG9ja2VyZmlsZS5DdXN0b20nKSk7XG5cbiAgLy8gZGVwbG95IGEgZG9ja2VyIGltYWdlIHdpdGggY3VzdG9tIGZpbGUgd2l0aG91dCBzeW50aCAodXNlcyBhc3NldHMpXG4gIGF3YWl0IGNka0RlcGxveSgnZG9ja2VyLXdpdGgtY3VzdG9tLWZpbGUnLCB7IG9wdGlvbnM6IFsnLWEnLCAnLiddLCBjd2Q6IGFzbU91dHB1dERpciB9KTtcbn0pO1xuXG5hc3luYyBmdW5jdGlvbiBsaXN0Q2hpbGRyZW4ocGFyZW50OiBzdHJpbmcsIHByZWQ6ICh4OiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj4pIHtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgZm9yIChjb25zdCBjaGlsZCBvZiBhd2FpdCBmcy5yZWFkZGlyKHBhcmVudCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KSkge1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5qb2luKHBhcmVudCwgY2hpbGQudG9TdHJpbmcoKSk7XG4gICAgaWYgKGF3YWl0IHByZWQoZnVsbFBhdGgpKSB7XG4gICAgICByZXQucHVzaChmdWxsUGF0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGxpc3RDaGlsZERpcnMocGFyZW50OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGxpc3RDaGlsZHJlbihwYXJlbnQsIGFzeW5jIChmdWxsUGF0aDogc3RyaW5nKSA9PiAoYXdhaXQgZnMuc3RhdChmdWxsUGF0aCkpLmlzRGlyZWN0b3J5KCkpO1xufVxuIl19