"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rememberToDeleteBucket = exports.shell = exports.cleanup = exports.deleteableStacks = exports.prepareAppFixture = exports.cloneDirectory = exports.fullStackName = exports.cdk = exports.cdkDestroy = exports.cdkDeploy = exports.log = exports.STACK_NAME_PREFIX = exports.INTEG_TEST_DIR = void 0;
const child_process = require("child_process");
const os = require("os");
const path = require("path");
const aws_helpers_1 = require("./aws-helpers");
exports.INTEG_TEST_DIR = path.join(os.tmpdir(), 'cdk-integ-test2');
exports.STACK_NAME_PREFIX = process.env.STACK_NAME_PREFIX || (() => {
    // Make the stack names unique based on the codebuild project name
    // (if it exists). This prevents multiple codebuild projects stomping
    // on each other's stacks and failing them.
    //
    // The get codebuild project name from the ID: PROJECT_NAME:1238a83
    if (process.env.CODEBUILD_BUILD_ID) {
        return process.env.CODEBUILD_BUILD_ID.split(':')[0];
    }
    if (process.env.IS_CANARY === 'true') {
        return 'cdk-toolkit-canary';
    }
    return 'cdk-toolkit-integration';
})();
function log(x) {
    process.stderr.write(x + '\n');
}
exports.log = log;
async function cdkDeploy(stackNames, options = {}) {
    var _a, _b;
    stackNames = typeof stackNames === 'string' ? [stackNames] : stackNames;
    const neverRequireApproval = (_a = options.neverRequireApproval) !== null && _a !== void 0 ? _a : true;
    return await cdk(['deploy',
        ...(neverRequireApproval ? ['--require-approval=never'] : []), // Default to no approval in an unattended test
        ...((_b = options.options) !== null && _b !== void 0 ? _b : []), ...fullStackName(stackNames)], options);
}
exports.cdkDeploy = cdkDeploy;
async function cdkDestroy(stackNames, options = {}) {
    var _a;
    stackNames = typeof stackNames === 'string' ? [stackNames] : stackNames;
    return await cdk(['destroy',
        '-f', // We never want a prompt in an unattended test
        ...((_a = options.options) !== null && _a !== void 0 ? _a : []), ...fullStackName(stackNames)], options);
}
exports.cdkDestroy = cdkDestroy;
async function cdk(args, options = {}) {
    return await shell(['cdk', ...args], {
        cwd: exports.INTEG_TEST_DIR,
        ...options,
        modEnv: {
            AWS_REGION: (await aws_helpers_1.testEnv()).region,
            AWS_DEFAULT_REGION: (await aws_helpers_1.testEnv()).region,
            STACK_NAME_PREFIX: exports.STACK_NAME_PREFIX,
            ...options.modEnv,
        },
    });
}
exports.cdk = cdk;
function fullStackName(stackNames) {
    if (typeof stackNames === 'string') {
        return `${exports.STACK_NAME_PREFIX}-${stackNames}`;
    }
    else {
        return stackNames.map(s => `${exports.STACK_NAME_PREFIX}-${s}`);
    }
}
exports.fullStackName = fullStackName;
/**
 * Prepare a target dir byreplicating a source directory
 */
async function cloneDirectory(source, target) {
    await shell(['rm', '-rf', target]);
    await shell(['mkdir', '-p', target]);
    await shell(['cp', '-R', source + '/*', target]);
}
exports.cloneDirectory = cloneDirectory;
/**
 * Prepare the app fixture
 *
 * If this is done in the main test script, it will be skipped
 * in the subprocess scripts since the app fixture can just be reused.
 */
async function prepareAppFixture() {
    await cloneDirectory(path.join(__dirname, 'app'), exports.INTEG_TEST_DIR);
    await shell(['npm', 'install',
        '@aws-cdk/core',
        '@aws-cdk/aws-sns',
        '@aws-cdk/aws-iam',
        '@aws-cdk/aws-lambda',
        '@aws-cdk/aws-ssm',
        '@aws-cdk/aws-ecr-assets',
        '@aws-cdk/aws-cloudformation',
        '@aws-cdk/aws-ec2'], {
        cwd: exports.INTEG_TEST_DIR,
    });
}
exports.prepareAppFixture = prepareAppFixture;
/**
 * Return the stacks starting with our testing prefix that should be deleted
 */
async function deleteableStacks(prefix) {
    var _a;
    const statusFilter = [
        'CREATE_IN_PROGRESS', 'CREATE_FAILED', 'CREATE_COMPLETE',
        'ROLLBACK_IN_PROGRESS', 'ROLLBACK_FAILED', 'ROLLBACK_COMPLETE',
        'DELETE_FAILED',
        'UPDATE_IN_PROGRESS', 'UPDATE_COMPLETE_CLEANUP_IN_PROGRESS',
        'UPDATE_COMPLETE', 'UPDATE_ROLLBACK_IN_PROGRESS',
        'UPDATE_ROLLBACK_FAILED',
        'UPDATE_ROLLBACK_COMPLETE_CLEANUP_IN_PROGRESS',
        'UPDATE_ROLLBACK_COMPLETE', 'REVIEW_IN_PROGRESS',
        'IMPORT_IN_PROGRESS', 'IMPORT_COMPLETE',
        'IMPORT_ROLLBACK_IN_PROGRESS', 'IMPORT_ROLLBACK_FAILED',
        'IMPORT_ROLLBACK_COMPLETE',
    ];
    const response = await aws_helpers_1.cloudFormation('describeStacks', {});
    return ((_a = response.Stacks) !== null && _a !== void 0 ? _a : [])
        .filter(s => s.StackName.startsWith(prefix))
        .filter(s => statusFilter.includes(s.StackStatus));
}
exports.deleteableStacks = deleteableStacks;
/**
 * Cleanup leftover stacks and buckets
 */
async function cleanup() {
    const stacksToDelete = await deleteableStacks(exports.STACK_NAME_PREFIX);
    // Bootstrap stacks have buckets that need to be cleaned
    const bucketNames = stacksToDelete.map(stack => aws_helpers_1.outputFromStack('BucketName', stack)).filter(defined);
    await Promise.all(bucketNames.map(aws_helpers_1.emptyBucket));
    // Bootstrap stacks have ECR repositories with images which should be deleted
    const imageRepositoryNames = stacksToDelete.map(stack => aws_helpers_1.outputFromStack('ImageRepositoryName', stack)).filter(defined);
    await Promise.all(imageRepositoryNames.map(aws_helpers_1.deleteImageRepository));
    await aws_helpers_1.deleteStacks(...stacksToDelete.map(s => s.StackName));
    // We might have leaked some buckets by upgrading the bootstrap stack. Be
    // sure to clean everything.
    for (const bucket of bucketsToDelete) {
        await aws_helpers_1.deleteBucket(bucket);
    }
    bucketsToDelete = [];
}
exports.cleanup = cleanup;
/**
 * A shell command that does what you want
 *
 * Is platform-aware, handles errors nicely.
 */
async function shell(command, options = {}) {
    var _a;
    if (options.modEnv && options.env) {
        throw new Error('Use either env or modEnv but not both');
    }
    log(`ðŸ’» ${command.join(' ')}`);
    const env = (_a = options.env) !== null && _a !== void 0 ? _a : (options.modEnv ? { ...process.env, ...options.modEnv } : undefined);
    const child = child_process.spawn(command[0], command.slice(1), {
        ...options,
        env,
        // Need this for Windows where we want .cmd and .bat to be found as well.
        shell: true,
        stdio: ['ignore', 'pipe', 'pipe'],
    });
    return new Promise((resolve, reject) => {
        const stdout = new Array();
        const stderr = new Array();
        child.stdout.on('data', chunk => {
            process.stdout.write(chunk);
            stdout.push(chunk);
        });
        child.stderr.on('data', chunk => {
            var _a;
            process.stderr.write(chunk);
            if ((_a = options.captureStderr) !== null && _a !== void 0 ? _a : true) {
                stderr.push(chunk);
            }
        });
        child.once('error', reject);
        child.once('close', code => {
            if (code === 0 || options.allowErrExit) {
                resolve((Buffer.concat(stdout).toString('utf-8') + Buffer.concat(stderr).toString('utf-8')).trim());
            }
            else {
                reject(new Error(`'${command.join(' ')}' exited with error code ${code}: ${Buffer.concat(stderr).toString('utf-8').trim()}`));
            }
        });
    });
}
exports.shell = shell;
let bucketsToDelete = new Array();
/**
 * Append this to the list of buckets to potentially delete
 *
 * At the end of a test, we clean up buckets that may not have gotten destroyed
 * (for whatever reason).
 */
function rememberToDeleteBucket(bucketName) {
    bucketsToDelete.push(bucketName);
}
exports.rememberToDeleteBucket = rememberToDeleteBucket;
function defined(x) {
    return x !== undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLWhlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjZGstaGVscGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwrQ0FBK0M7QUFDL0MseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwrQ0FBeUk7QUFFNUgsUUFBQSxjQUFjLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztBQUUzRCxRQUFBLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLElBQUksQ0FBQyxHQUFHLEVBQUU7SUFDdEUsa0VBQWtFO0lBQ2xFLHFFQUFxRTtJQUNyRSwyQ0FBMkM7SUFDM0MsRUFBRTtJQUNGLG1FQUFtRTtJQUNuRSxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLEVBQUU7UUFBRSxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQUU7SUFDNUYsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsS0FBSyxNQUFNLEVBQUU7UUFBRSxPQUFPLG9CQUFvQixDQUFDO0tBQUU7SUFDdEUsT0FBTyx5QkFBeUIsQ0FBQztBQUNuQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBNEJMLFNBQWdCLEdBQUcsQ0FBQyxDQUFTO0lBQzNCLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBRkQsa0JBRUM7QUFFTSxLQUFLLFVBQVUsU0FBUyxDQUFDLFVBQTZCLEVBQUUsVUFBeUIsRUFBRTs7SUFDeEYsVUFBVSxHQUFHLE9BQU8sVUFBVSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO0lBRXhFLE1BQU0sb0JBQW9CLFNB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QyxZQUFZLEVBQUU7Z0JBQ3RDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQzthQUNyRztpQkFBTTtnQkFDTCxNQUFNLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsSUFBSSxLQUFLLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQy9IO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUEzQ0Qsc0JBMkNDO0FBRUQsSUFBSSxlQUFlLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztBQUUxQzs7Ozs7R0FLRztBQUNILFNBQWdCLHNCQUFzQixDQUFDLFVBQWtCO0lBQ3ZELGVBQWUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDbkMsQ0FBQztBQUZELHdEQUVDO0FBRUQsU0FBUyxPQUFPLENBQUksQ0FBSTtJQUN0QixPQUFPLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDekIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkX3Byb2Nlc3MgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgY2xvdWRGb3JtYXRpb24sIGRlbGV0ZUJ1Y2tldCwgZGVsZXRlSW1hZ2VSZXBvc2l0b3J5LCBkZWxldGVTdGFja3MsIGVtcHR5QnVja2V0LCBvdXRwdXRGcm9tU3RhY2ssIHRlc3RFbnYgfSBmcm9tICcuL2F3cy1oZWxwZXJzJztcblxuZXhwb3J0IGNvbnN0IElOVEVHX1RFU1RfRElSID0gcGF0aC5qb2luKG9zLnRtcGRpcigpLCAnY2RrLWludGVnLXRlc3QyJyk7XG5cbmV4cG9ydCBjb25zdCBTVEFDS19OQU1FX1BSRUZJWCA9IHByb2Nlc3MuZW52LlNUQUNLX05BTUVfUFJFRklYIHx8ICgoKSA9PiB7XG4gIC8vIE1ha2UgdGhlIHN0YWNrIG5hbWVzIHVuaXF1ZSBiYXNlZCBvbiB0aGUgY29kZWJ1aWxkIHByb2plY3QgbmFtZVxuICAvLyAoaWYgaXQgZXhpc3RzKS4gVGhpcyBwcmV2ZW50cyBtdWx0aXBsZSBjb2RlYnVpbGQgcHJvamVjdHMgc3RvbXBpbmdcbiAgLy8gb24gZWFjaCBvdGhlcidzIHN0YWNrcyBhbmQgZmFpbGluZyB0aGVtLlxuICAvL1xuICAvLyBUaGUgZ2V0IGNvZGVidWlsZCBwcm9qZWN0IG5hbWUgZnJvbSB0aGUgSUQ6IFBST0pFQ1RfTkFNRToxMjM4YTgzXG4gIGlmIChwcm9jZXNzLmVudi5DT0RFQlVJTERfQlVJTERfSUQpIHsgcmV0dXJuIHByb2Nlc3MuZW52LkNPREVCVUlMRF9CVUlMRF9JRC5zcGxpdCgnOicpWzBdOyB9XG4gIGlmIChwcm9jZXNzLmVudi5JU19DQU5BUlkgPT09ICd0cnVlJykgeyByZXR1cm4gJ2Nkay10b29sa2l0LWNhbmFyeSc7IH1cbiAgcmV0dXJuICdjZGstdG9vbGtpdC1pbnRlZ3JhdGlvbic7XG59KSgpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNoZWxsT3B0aW9ucyBleHRlbmRzIGNoaWxkX3Byb2Nlc3MuU3Bhd25PcHRpb25zIHtcbiAgLyoqXG4gICAqIFByb3BlcnRpZXMgdG8gYWRkIHRvICdlbnYnXG4gICAqL1xuICBtb2RFbnY/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBEb24ndCBmYWlsIHdoZW4gZXhpdGluZyB3aXRoIGFuIGVycm9yXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBhbGxvd0VyckV4aXQ/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGNhcHR1cmUgc3RkZXJyXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGNhcHR1cmVTdGRlcnI/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENka0NsaU9wdGlvbnMgZXh0ZW5kcyBTaGVsbE9wdGlvbnMge1xuICBvcHRpb25zPzogc3RyaW5nW107XG4gIG5ldmVyUmVxdWlyZUFwcHJvdmFsPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvZyh4OiBzdHJpbmcpIHtcbiAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoeCArICdcXG4nKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNka0RlcGxveShzdGFja05hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSwgb3B0aW9uczogQ2RrQ2xpT3B0aW9ucyA9IHt9KSB7XG4gIHN0YWNrTmFtZXMgPSB0eXBlb2Ygc3RhY2tOYW1lcyA9PT0gJ3N0cmluZycgPyBbc3RhY2tOYW1lc10gOiBzdGFja05hbWVzO1xuXG4gIGNvbnN0IG5ldmVyUmVxdWlyZUFwcHJvdmFsID0gb3B0aW9ucy5uZXZlclJlcXVpcmVBcHByb3ZhbCA/PyB0cnVlO1xuXG4gIHJldHVybiBhd2FpdCBjZGsoWydkZXBsb3knLFxuICAgIC4uLihuZXZlclJlcXVpcmVBcHByb3ZhbCA/IFsnLS1yZXF1aXJlLWFwcHJvdmFsPW5ldmVyJ10gOiBbXSksIC8vIERlZmF1bHQgdG8gbm8gYXBwcm92YWwgaW4gYW4gdW5hdHRlbmRlZCB0ZXN0XG4gICAgLi4uKG9wdGlvbnMub3B0aW9ucyA/PyBbXSksXG4gICAgLi4uZnVsbFN0YWNrTmFtZShzdGFja05hbWVzKV0sIG9wdGlvbnMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2RrRGVzdHJveShzdGFja05hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSwgb3B0aW9uczogQ2RrQ2xpT3B0aW9ucyA9IHt9KSB7XG4gIHN0YWNrTmFtZXMgPSB0eXBlb2Ygc3RhY2tOYW1lcyA9PT0gJ3N0cmluZycgPyBbc3RhY2tOYW1lc10gOiBzdGFja05hbWVzO1xuXG4gIHJldHVybiBhd2FpdCBjZGsoWydkZXN0cm95JyxcbiAgICAnLWYnLCAvLyBXZSBuZXZlciB3YW50IGEgcHJvbXB0IGluIGFuIHVuYXR0ZW5kZWQgdGVzdFxuICAgIC4uLihvcHRpb25zLm9wdGlvbnMgPz8gW10pLFxuICAgIC4uLmZ1bGxTdGFja05hbWUoc3RhY2tOYW1lcyldLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNkayhhcmdzOiBzdHJpbmdbXSwgb3B0aW9uczogQ2RrQ2xpT3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBhd2FpdCBzaGVsbChbJ2NkaycsIC4uLmFyZ3NdLCB7XG4gICAgY3dkOiBJTlRFR19URVNUX0RJUixcbiAgICAuLi5vcHRpb25zLFxuICAgIG1vZEVudjoge1xuICAgICAgQVdTX1JFR0lPTjogKGF3YWl0IHRlc3RFbnYoKSkucmVnaW9uLFxuICAgICAgQVdTX0RFRkFVTFRfUkVHSU9OOiAoYXdhaXQgdGVzdEVudigpKS5yZWdpb24sXG4gICAgICBTVEFDS19OQU1FX1BSRUZJWCxcbiAgICAgIC4uLm9wdGlvbnMubW9kRW52LFxuICAgIH0sXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVsbFN0YWNrTmFtZShzdGFja05hbWU6IHN0cmluZyk6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBmdWxsU3RhY2tOYW1lKHN0YWNrTmFtZXM6IHN0cmluZ1tdKTogc3RyaW5nW107XG5leHBvcnQgZnVuY3Rpb24gZnVsbFN0YWNrTmFtZShzdGFja05hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IHN0cmluZyB8IHN0cmluZ1tdIHtcbiAgaWYgKHR5cGVvZiBzdGFja05hbWVzID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBgJHtTVEFDS19OQU1FX1BSRUZJWH0tJHtzdGFja05hbWVzfWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0YWNrTmFtZXMubWFwKHMgPT4gYCR7U1RBQ0tfTkFNRV9QUkVGSVh9LSR7c31gKTtcbiAgfVxufVxuXG4vKipcbiAqIFByZXBhcmUgYSB0YXJnZXQgZGlyIGJ5cmVwbGljYXRpbmcgYSBzb3VyY2UgZGlyZWN0b3J5XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbG9uZURpcmVjdG9yeShzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpIHtcbiAgYXdhaXQgc2hlbGwoWydybScsICctcmYnLCB0YXJnZXRdKTtcbiAgYXdhaXQgc2hlbGwoWydta2RpcicsICctcCcsIHRhcmdldF0pO1xuICBhd2FpdCBzaGVsbChbJ2NwJywgJy1SJywgc291cmNlICsgJy8qJywgdGFyZ2V0XSk7XG59XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgYXBwIGZpeHR1cmVcbiAqXG4gKiBJZiB0aGlzIGlzIGRvbmUgaW4gdGhlIG1haW4gdGVzdCBzY3JpcHQsIGl0IHdpbGwgYmUgc2tpcHBlZFxuICogaW4gdGhlIHN1YnByb2Nlc3Mgc2NyaXB0cyBzaW5jZSB0aGUgYXBwIGZpeHR1cmUgY2FuIGp1c3QgYmUgcmV1c2VkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlcGFyZUFwcEZpeHR1cmUoKSB7XG4gIGF3YWl0IGNsb25lRGlyZWN0b3J5KHBhdGguam9pbihfX2Rpcm5hbWUsICdhcHAnKSwgSU5URUdfVEVTVF9ESVIpO1xuXG4gIGF3YWl0IHNoZWxsKFsnbnBtJywgJ2luc3RhbGwnLFxuICAgICdAYXdzLWNkay9jb3JlJyxcbiAgICAnQGF3cy1jZGsvYXdzLXNucycsXG4gICAgJ0Bhd3MtY2RrL2F3cy1pYW0nLFxuICAgICdAYXdzLWNkay9hd3MtbGFtYmRhJyxcbiAgICAnQGF3cy1jZGsvYXdzLXNzbScsXG4gICAgJ0Bhd3MtY2RrL2F3cy1lY3ItYXNzZXRzJyxcbiAgICAnQGF3cy1jZGsvYXdzLWNsb3VkZm9ybWF0aW9uJyxcbiAgICAnQGF3cy1jZGsvYXdzLWVjMiddLCB7XG4gICAgY3dkOiBJTlRFR19URVNUX0RJUixcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdGFja3Mgc3RhcnRpbmcgd2l0aCBvdXIgdGVzdGluZyBwcmVmaXggdGhhdCBzaG91bGQgYmUgZGVsZXRlZFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlYWJsZVN0YWNrcyhwcmVmaXg6IHN0cmluZyk6IFByb21pc2U8QVdTLkNsb3VkRm9ybWF0aW9uLlN0YWNrW10+IHtcbiAgY29uc3Qgc3RhdHVzRmlsdGVyID0gW1xuICAgICdDUkVBVEVfSU5fUFJPR1JFU1MnLCAnQ1JFQVRFX0ZBSUxFRCcsICdDUkVBVEVfQ09NUExFVEUnLFxuICAgICdST0xMQkFDS19JTl9QUk9HUkVTUycsICdST0xMQkFDS19GQUlMRUQnLCAnUk9MTEJBQ0tfQ09NUExFVEUnLFxuICAgICdERUxFVEVfRkFJTEVEJyxcbiAgICAnVVBEQVRFX0lOX1BST0dSRVNTJywgJ1VQREFURV9DT01QTEVURV9DTEVBTlVQX0lOX1BST0dSRVNTJyxcbiAgICAnVVBEQVRFX0NPTVBMRVRFJywgJ1VQREFURV9ST0xMQkFDS19JTl9QUk9HUkVTUycsXG4gICAgJ1VQREFURV9ST0xMQkFDS19GQUlMRUQnLFxuICAgICdVUERBVEVfUk9MTEJBQ0tfQ09NUExFVEVfQ0xFQU5VUF9JTl9QUk9HUkVTUycsXG4gICAgJ1VQREFURV9ST0xMQkFDS19DT01QTEVURScsICdSRVZJRVdfSU5fUFJPR1JFU1MnLFxuICAgICdJTVBPUlRfSU5fUFJPR1JFU1MnLCAnSU1QT1JUX0NPTVBMRVRFJyxcbiAgICAnSU1QT1JUX1JPTExCQUNLX0lOX1BST0dSRVNTJywgJ0lNUE9SVF9ST0xMQkFDS19GQUlMRUQnLFxuICAgICdJTVBPUlRfUk9MTEJBQ0tfQ09NUExFVEUnLFxuICBdO1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xvdWRGb3JtYXRpb24oJ2Rlc2NyaWJlU3RhY2tzJywge30pO1xuXG4gIHJldHVybiAocmVzcG9uc2UuU3RhY2tzID8/IFtdKVxuICAgIC5maWx0ZXIocyA9PiBzLlN0YWNrTmFtZS5zdGFydHNXaXRoKHByZWZpeCkpXG4gICAgLmZpbHRlcihzID0+IHN0YXR1c0ZpbHRlci5pbmNsdWRlcyhzLlN0YWNrU3RhdHVzKSk7XG59XG5cbi8qKlxuICogQ2xlYW51cCBsZWZ0b3ZlciBzdGFja3MgYW5kIGJ1Y2tldHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXAoKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHN0YWNrc1RvRGVsZXRlID0gYXdhaXQgZGVsZXRlYWJsZVN0YWNrcyhTVEFDS19OQU1FX1BSRUZJWCk7XG5cbiAgLy8gQm9vdHN0cmFwIHN0YWNrcyBoYXZlIGJ1Y2tldHMgdGhhdCBuZWVkIHRvIGJlIGNsZWFuZWRcbiAgY29uc3QgYnVja2V0TmFtZXMgPSBzdGFja3NUb0RlbGV0ZS5tYXAoc3RhY2sgPT4gb3V0cHV0RnJvbVN0YWNrKCdCdWNrZXROYW1lJywgc3RhY2spKS5maWx0ZXIoZGVmaW5lZCk7XG4gIGF3YWl0IFByb21pc2UuYWxsKGJ1Y2tldE5hbWVzLm1hcChlbXB0eUJ1Y2tldCkpO1xuXG4gIC8vIEJvb3RzdHJhcCBzdGFja3MgaGF2ZSBFQ1IgcmVwb3NpdG9yaWVzIHdpdGggaW1hZ2VzIHdoaWNoIHNob3VsZCBiZSBkZWxldGVkXG4gIGNvbnN0IGltYWdlUmVwb3NpdG9yeU5hbWVzID0gc3RhY2tzVG9EZWxldGUubWFwKHN0YWNrID0+IG91dHB1dEZyb21TdGFjaygnSW1hZ2VSZXBvc2l0b3J5TmFtZScsIHN0YWNrKSkuZmlsdGVyKGRlZmluZWQpO1xuICBhd2FpdCBQcm9taXNlLmFsbChpbWFnZVJlcG9zaXRvcnlOYW1lcy5tYXAoZGVsZXRlSW1hZ2VSZXBvc2l0b3J5KSk7XG5cbiAgYXdhaXQgZGVsZXRlU3RhY2tzKC4uLnN0YWNrc1RvRGVsZXRlLm1hcChzID0+IHMuU3RhY2tOYW1lKSk7XG5cbiAgLy8gV2UgbWlnaHQgaGF2ZSBsZWFrZWQgc29tZSBidWNrZXRzIGJ5IHVwZ3JhZGluZyB0aGUgYm9vdHN0cmFwIHN0YWNrLiBCZVxuICAvLyBzdXJlIHRvIGNsZWFuIGV2ZXJ5dGhpbmcuXG4gIGZvciAoY29uc3QgYnVja2V0IG9mIGJ1Y2tldHNUb0RlbGV0ZSkge1xuICAgIGF3YWl0IGRlbGV0ZUJ1Y2tldChidWNrZXQpO1xuICB9XG4gIGJ1Y2tldHNUb0RlbGV0ZSA9IFtdO1xufVxuXG4vKipcbiAqIEEgc2hlbGwgY29tbWFuZCB0aGF0IGRvZXMgd2hhdCB5b3Ugd2FudFxuICpcbiAqIElzIHBsYXRmb3JtLWF3YXJlLCBoYW5kbGVzIGVycm9ycyBuaWNlbHkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzaGVsbChjb21tYW5kOiBzdHJpbmdbXSwgb3B0aW9uczogU2hlbGxPcHRpb25zID0ge30pOiBQcm9taXNlPHN0cmluZz4ge1xuICBpZiAob3B0aW9ucy5tb2RFbnYgJiYgb3B0aW9ucy5lbnYpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZSBlaXRoZXIgZW52IG9yIG1vZEVudiBidXQgbm90IGJvdGgnKTtcbiAgfVxuXG4gIGxvZyhg8J+SuyAke2NvbW1hbmQuam9pbignICcpfWApO1xuXG4gIGNvbnN0IGVudiA9IG9wdGlvbnMuZW52ID8/IChvcHRpb25zLm1vZEVudiA/IHsuLi5wcm9jZXNzLmVudiwgLi4ub3B0aW9ucy5tb2RFbnZ9IDogdW5kZWZpbmVkKTtcblxuICBjb25zdCBjaGlsZCA9IGNoaWxkX3Byb2Nlc3Muc3Bhd24oY29tbWFuZFswXSwgY29tbWFuZC5zbGljZSgxKSwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgZW52LFxuICAgIC8vIE5lZWQgdGhpcyBmb3IgV2luZG93cyB3aGVyZSB3ZSB3YW50IC5jbWQgYW5kIC5iYXQgdG8gYmUgZm91bmQgYXMgd2VsbC5cbiAgICBzaGVsbDogdHJ1ZSxcbiAgICBzdGRpbzogWyAnaWdub3JlJywgJ3BpcGUnLCAncGlwZScgXSxcbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHN0ZG91dCA9IG5ldyBBcnJheTxCdWZmZXI+KCk7XG4gICAgY29uc3Qgc3RkZXJyID0gbmV3IEFycmF5PEJ1ZmZlcj4oKTtcblxuICAgIGNoaWxkLnN0ZG91dCEub24oJ2RhdGEnLCBjaHVuayA9PiB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjaHVuayk7XG4gICAgICBzdGRvdXQucHVzaChjaHVuayk7XG4gICAgfSk7XG5cbiAgICBjaGlsZC5zdGRlcnIhLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUoY2h1bmspO1xuICAgICAgaWYgKG9wdGlvbnMuY2FwdHVyZVN0ZGVyciA/PyB0cnVlKSB7XG4gICAgICAgIHN0ZGVyci5wdXNoKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNoaWxkLm9uY2UoJ2Vycm9yJywgcmVqZWN0KTtcblxuICAgIGNoaWxkLm9uY2UoJ2Nsb3NlJywgY29kZSA9PiB7XG4gICAgICBpZiAoY29kZSA9PT0gMCB8fCBvcHRpb25zLmFsbG93RXJyRXhpdCkge1xuICAgICAgICByZXNvbHZlKChCdWZmZXIuY29uY2F0KHN0ZG91dCkudG9TdHJpbmcoJ3V0Zi04JykgKyBCdWZmZXIuY29uY2F0KHN0ZGVycikudG9TdHJpbmcoJ3V0Zi04JykpLnRyaW0oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGAnJHtjb21tYW5kLmpvaW4oJyAnKX0nIGV4aXRlZCB3aXRoIGVycm9yIGNvZGUgJHtjb2RlfTogJHtCdWZmZXIuY29uY2F0KHN0ZGVycikudG9TdHJpbmcoJ3V0Zi04JykudHJpbSgpfWApKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmxldCBidWNrZXRzVG9EZWxldGUgPSBuZXcgQXJyYXk8c3RyaW5nPigpO1xuXG4vKipcbiAqIEFwcGVuZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGJ1Y2tldHMgdG8gcG90ZW50aWFsbHkgZGVsZXRlXG4gKlxuICogQXQgdGhlIGVuZCBvZiBhIHRlc3QsIHdlIGNsZWFuIHVwIGJ1Y2tldHMgdGhhdCBtYXkgbm90IGhhdmUgZ290dGVuIGRlc3Ryb3llZFxuICogKGZvciB3aGF0ZXZlciByZWFzb24pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtZW1iZXJUb0RlbGV0ZUJ1Y2tldChidWNrZXROYW1lOiBzdHJpbmcpIHtcbiAgYnVja2V0c1RvRGVsZXRlLnB1c2goYnVja2V0TmFtZSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZWQ8QT4oeDogQSk6IHggaXMgTm9uTnVsbGFibGU8QT4ge1xuICByZXR1cm4geCAhPT0gdW5kZWZpbmVkO1xufSJdfQ==