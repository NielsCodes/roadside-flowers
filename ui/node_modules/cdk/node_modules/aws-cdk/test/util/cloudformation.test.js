"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cloudformation_1 = require("../../lib/api/util/cloudformation");
const mock_sdk_1 = require("./mock-sdk");
const PARAM = 'TheParameter';
const DEFAULT = 'TheDefault';
const OVERRIDE = 'TheOverride';
const USE_OVERRIDE = { ParameterKey: PARAM, ParameterValue: OVERRIDE };
const USE_PREVIOUS = { ParameterKey: PARAM, UsePreviousValue: true };
let sdkProvider;
let cfnMocks;
let cfn;
beforeEach(async () => {
    sdkProvider = new mock_sdk_1.MockSdkProvider();
    cfnMocks = {
        describeStacks: jest.fn()
            // No stacks exist
            .mockImplementation(() => ({ Stacks: [] })),
    };
    sdkProvider.stubCloudFormation(cfnMocks);
    cfn = (await sdkProvider.forEnvironment()).cloudFormation();
});
test('A non-existent stack pretends to have an empty template', async () => {
    // WHEN
    const stack = await cloudformation_1.CloudFormationStack.lookup(cfn, 'Dummy');
    // THEN
    expect(await stack.template()).toEqual({});
});
test.each([
    [false, false],
    [false, true],
    [true, false],
    [true, true]
])('given override, always use the override (parameter has a default: %p, parameter previously supplied: %p)', (haveDefault, havePrevious) => {
    expect(makeParams(haveDefault, havePrevious, true)).toEqual({
        apiParameters: [USE_OVERRIDE],
        changed: true,
    });
});
test('no default, no prev, no override => error', () => {
    expect(() => makeParams(false, false, false)).toThrow(/missing a value: TheParameter/);
});
test('no default, yes prev, no override => use previous', () => {
    expect(makeParams(false, true, false)).toEqual({
        apiParameters: [USE_PREVIOUS],
        changed: false,
    });
});
test('default, no prev, no override => empty param set', () => {
    expect(makeParams(true, false, false)).toEqual({
        apiParameters: [],
        changed: false,
    });
});
test('default, prev, no override => use previous', () => {
    expect(makeParams(true, true, false)).toEqual({
        apiParameters: [USE_PREVIOUS],
        changed: false,
    });
});
test('if a parameter is retrieved from SSM, the parameters always count as changed', () => {
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: {
                Type: 'AWS::SSM::Parameter::Name',
                Default: '/Some/Key',
            },
        },
    });
    // If we don't pass a new value
    expect(params.diff({}, { Foo: '/Some/Key' }).changed).toEqual(true);
    // If we do pass a new value but it's the same as the old one
    expect(params.diff({ Foo: '/Some/Key' }, { Foo: '/Some/Key' }).changed).toEqual(true);
});
test('unknown parameter in overrides, pass it anyway', () => {
    // Not sure if we really want this. It seems like it would be nice
    // to not pass parameters that aren't expected, given that CFN will
    // just error out. But maybe we want to be warned of typos...
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: { Type: 'String', Default: 'Foo' },
        },
    });
    expect(params.diff({ Bar: 'Bar' }, {}).apiParameters).toEqual([
        { ParameterKey: 'Bar', ParameterValue: 'Bar' },
    ]);
});
function makeParams(defaultValue, hasPrevValue, override) {
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            [PARAM]: {
                Type: 'String',
                Default: defaultValue ? DEFAULT : undefined,
            },
        },
    });
    const prevParams = hasPrevValue ? { [PARAM]: 'Foo' } : {};
    const stackParams = params.diff({ [PARAM]: override ? OVERRIDE : undefined }, prevParams);
    return { apiParameters: stackParams.apiParameters, changed: stackParams.changed };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24udGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNsb3VkZm9ybWF0aW9uLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxzRUFBNEY7QUFDNUYseUNBQWdGO0FBRWhGLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQztBQUM3QixNQUFNLE9BQU8sR0FBRyxZQUFZLENBQUM7QUFDN0IsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDO0FBRS9CLE1BQU0sWUFBWSxHQUFHLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLENBQUM7QUFDdkUsTUFBTSxZQUFZLEdBQUcsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRSxDQUFDO0FBRXJFLElBQUksV0FBNEIsQ0FBQztBQUNqQyxJQUFJLFFBQStELENBQUM7QUFDcEUsSUFBSSxHQUF1QixDQUFDO0FBQzVCLFVBQVUsQ0FBQyxLQUFLLElBQUksRUFBRTtJQUNwQixXQUFXLEdBQUcsSUFBSSwwQkFBZSxFQUFFLENBQUM7SUFFcEMsUUFBUSxHQUFHO1FBQ1QsY0FBYyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDdkIsa0JBQWtCO2FBQ2pCLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztLQUM5QyxDQUFDO0lBQ0YsV0FBVyxDQUFDLGtCQUFrQixDQUFDLFFBQWUsQ0FBQyxDQUFDO0lBQ2hELEdBQUcsR0FBRyxDQUFDLE1BQU0sV0FBVyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDOUQsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMseURBQXlELEVBQUUsS0FBSyxJQUFJLEVBQUU7SUFDekUsT0FBTztJQUNQLE1BQU0sS0FBSyxHQUFHLE1BQU0sb0NBQW1CLENBQUMsTUFBTSxDQUFD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LEVBQUUsQ0FBQztBQUNwRixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25TdGFjaywgVGVtcGxhdGVQYXJhbWV0ZXJzIH0gZnJvbSAnLi4vLi4vbGliL2FwaS91dGlsL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IE1vY2tlZE9iamVjdCwgTW9ja1Nka1Byb3ZpZGVyLCBTeW5jSGFuZGxlclN1YnNldE9mIH0gZnJvbSAnLi9tb2NrLXNkayc7XG5cbmNvbnN0IFBBUkFNID0gJ1RoZVBhcmFtZXRlcic7XG5jb25zdCBERUZBVUxUID0gJ1RoZURlZmF1bHQnO1xuY29uc3QgT1ZFUlJJREUgPSAnVGhlT3ZlcnJpZGUnO1xuXG5jb25zdCBVU0VfT1ZFUlJJREUgPSB7IFBhcmFtZXRlcktleTogUEFSQU0sIFBhcmFtZXRlclZhbHVlOiBPVkVSUklERSB9O1xuY29uc3QgVVNFX1BSRVZJT1VTID0geyBQYXJhbWV0ZXJLZXk6IFBBUkFNLCBVc2VQcmV2aW91c1ZhbHVlOiB0cnVlIH07XG5cbmxldCBzZGtQcm92aWRlcjogTW9ja1Nka1Byb3ZpZGVyO1xubGV0IGNmbk1vY2tzOiBNb2NrZWRPYmplY3Q8U3luY0hhbmRsZXJTdWJzZXRPZjxBV1MuQ2xvdWRGb3JtYXRpb24+PjtcbmxldCBjZm46IEFXUy5DbG91ZEZvcm1hdGlvbjtcbmJlZm9yZUVhY2goYXN5bmMgKCkgPT4ge1xuICBzZGtQcm92aWRlciA9IG5ldyBNb2NrU2RrUHJvdmlkZXIoKTtcblxuICBjZm5Nb2NrcyA9IHtcbiAgICBkZXNjcmliZVN0YWNrczogamVzdC5mbigpXG4gICAgICAvLyBObyBzdGFja3MgZXhpc3RcbiAgICAgIC5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHsgU3RhY2tzOiBbXSB9KSksXG4gIH07XG4gIHNka1Byb3ZpZGVyLnN0dWJDbG91ZEZvcm1hdGlvbihjZm5Nb2NrcyBhcyBhbnkpO1xuICBjZm4gPSAoYXdhaXQgc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoKSkuY2xvdWRGb3JtYXRpb24oKTtcbn0pO1xuXG50ZXN0KCdBIG5vbi1leGlzdGVudCBzdGFjayBwcmV0ZW5kcyB0byBoYXZlIGFuIGVtcHR5IHRlbXBsYXRlJywgYXN5bmMgKCkgPT4ge1xuICAvLyBXSEVOXG4gIGNvbnN0IHN0YWNrID0gYXdhaXQgQ2xvdWRGb3JtYXRpb25TdGFjay5sb29rdXAoY2ZuLCAnRHVtbXknKTtcblxuICAvLyBUSEVOXG4gIGV4cGVjdChhd2FpdCBzdGFjay50ZW1wbGF0ZSgpKS50b0VxdWFsKHt9KTtcbn0pO1xuXG50ZXN0LmVhY2goW1xuICBbZmFsc2UsIGZhbHNlXSxcbiAgW2ZhbHNlLCB0cnVlXSxcbiAgW3RydWUsIGZhbHNlXSxcbiAgW3RydWUsIHRydWVdXSkoJ2dpdmVuIG92ZXJyaWRlLCBhbHdheXMgdXNlIHRoZSBvdmVycmlkZSAocGFyYW1ldGVyIGhhcyBhIGRlZmF1bHQ6ICVwLCBwYXJhbWV0ZXIgcHJldmlvdXNseSBzdXBwbGllZDogJXApJyxcbiAgKGhhdmVEZWZhdWx0LCBoYXZlUHJldmlvdXMpID0+IHtcbiAgICBleHBlY3QobWFrZVBhcmFtcyhoYXZlRGVmYXVsdCwgaGF2ZVByZXZpb3VzLCB0cnVlKSkudG9FcXVhbCh7XG4gICAgICBhcGlQYXJhbWV0ZXJzOiBbVVNFX09WRVJSSURFXSxcbiAgICAgIGNoYW5nZWQ6IHRydWUsXG4gICAgfSk7XG4gIH0pO1xuXG50ZXN0KCdubyBkZWZhdWx0LCBubyBwcmV2LCBubyBvdmVycmlkZSA9PiBlcnJvcicsICgpID0+IHtcbiAgZXhwZWN0KCgpID0+IG1ha2VQYXJhbXMoZmFsc2UsIGZhbHNlLCBmYWxzZSkpLnRvVGhyb3coL21pc3NpbmcgYSB2YWx1ZTogVGhlUGFyYW1ldGVyLyk7XG59KTtcblxudGVzdCgnbm8gZGVmYXVsdCwgeWVzIHByZXYsIG5vIG92ZXJyaWRlID0+IHVzZSBwcmV2aW91cycsICgpID0+IHtcbiAgZXhwZWN0KG1ha2VQYXJhbXMoZmFsc2UsIHRydWUsIGZhbHNlKSkudG9FcXVhbCh7XG4gICAgYXBpUGFyYW1ldGVyczogW1VTRV9QUkVWSU9VU10sXG4gICAgY2hhbmdlZDogZmFsc2UsXG4gIH0pO1xufSk7XG5cbnRlc3QoJ2RlZmF1bHQsIG5vIHByZXYsIG5vIG92ZXJyaWRlID0+IGVtcHR5IHBhcmFtIHNldCcsICgpID0+IHtcbiAgZXhwZWN0KG1ha2VQYXJhbXModHJ1ZSwgZmFsc2UsIGZhbHNlKSkudG9FcXVhbCh7XG4gICAgYXBpUGFyYW1ldGVyczogW10sXG4gICAgY2hhbmdlZDogZmFsc2UsXG4gIH0pO1xufSk7XG5cbnRlc3QoJ2RlZmF1bHQsIHByZXYsIG5vIG92ZXJyaWRlID0+IHVzZSBwcmV2aW91cycsICgpID0+IHtcbiAgZXhwZWN0KG1ha2VQYXJhbXModHJ1ZSwgdHJ1ZSwgZmFsc2UpKS50b0VxdWFsKHtcbiAgICBhcGlQYXJhbWV0ZXJzOiBbVVNFX1BSRVZJT1VTXSxcbiAgICBjaGFuZ2VkOiBmYWxzZSxcbiAgfSk7XG59KTtcblxudGVzdCgnaWYgYSBwYXJhbWV0ZXIgaXMgcmV0cmlldmVkIGZyb20gU1NNLCB0aGUgcGFyYW1ldGVycyBhbHdheXMgY291bnQgYXMgY2hhbmdlZCcsICgpID0+IHtcbiAgY29uc3QgcGFyYW1zID0gVGVtcGxhdGVQYXJhbWV0ZXJzLmZyb21UZW1wbGF0ZSh7XG4gICAgUGFyYW1ldGVyczoge1xuICAgICAgRm9vOiB7XG4gICAgICAgIFR5cGU6ICdBV1M6OlNTTTo6UGFyYW1ldGVyOjpOYW1lJyxcbiAgICAgICAgRGVmYXVsdDogJy9Tb21lL0tleScsXG4gICAgICB9LFxuICAgIH0sXG4gIH0pO1xuXG4gIC8vIElmIHdlIGRvbid0IHBhc3MgYSBuZXcgdmFsdWVcbiAgZXhwZWN0KHBhcmFtcy5kaWZmKHt9LCB7Rm9vOiAnL1NvbWUvS2V5J30pLmNoYW5nZWQpLnRvRXF1YWwodHJ1ZSk7XG5cbiAgLy8gSWYgd2UgZG8gcGFzcyBhIG5ldyB2YWx1ZSBidXQgaXQncyB0aGUgc2FtZSBhcyB0aGUgb2xkIG9uZVxuICBleHBlY3QocGFyYW1zLmRpZmYoe0ZvbzogJy9Tb21lL0tleSd9LCB7Rm9vOiAnL1NvbWUvS2V5J30pLmNoYW5nZWQpLnRvRXF1YWwodHJ1ZSk7XG59KTtcblxudGVzdCgndW5rbm93biBwYXJhbWV0ZXIgaW4gb3ZlcnJpZGVzLCBwYXNzIGl0IGFueXdheScsICgpID0+IHtcbiAgLy8gTm90IHN1cmUgaWYgd2UgcmVhbGx5IHdhbnQgdGhpcy4gSXQgc2VlbXMgbGlrZSBpdCB3b3VsZCBiZSBuaWNlXG4gIC8vIHRvIG5vdCBwYXNzIHBhcmFtZXRlcnMgdGhhdCBhcmVuJ3QgZXhwZWN0ZWQsIGdpdmVuIHRoYXQgQ0ZOIHdpbGxcbiAgLy8ganVzdCBlcnJvciBvdXQuIEJ1dCBtYXliZSB3ZSB3YW50IHRvIGJlIHdhcm5lZCBvZiB0eXBvcy4uLlxuICBjb25zdCBwYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKHtcbiAgICBQYXJhbWV0ZXJzOiB7XG4gICAgICBGb286IHsgVHlwZTogJ1N0cmluZycsIERlZmF1bHQ6ICdGb28nIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgZXhwZWN0KHBhcmFtcy5kaWZmKHsgQmFyOiAnQmFyJyB9LCB7fSkuYXBpUGFyYW1ldGVycykudG9FcXVhbChbXG4gICAgeyBQYXJhbWV0ZXJLZXk6ICdCYXInLCBQYXJhbWV0ZXJWYWx1ZTogJ0JhcicgfSxcbiAgXSk7XG59KTtcblxuZnVuY3Rpb24gbWFrZVBhcmFtcyhkZWZhdWx0VmFsdWU6IGJvb2xlYW4sIGhhc1ByZXZWYWx1ZTogYm9vbGVhbiwgb3ZlcnJpZGU6IGJvb2xlYW4pIHtcbiAgY29uc3QgcGFyYW1zID0gVGVtcGxhdGVQYXJhbWV0ZXJzLmZyb21UZW1wbGF0ZSh7XG4gICAgUGFyYW1ldGVyczoge1xuICAgICAgW1BBUkFNXToge1xuICAgICAgICBUeXBlOiAnU3RyaW5nJyxcbiAgICAgICAgRGVmYXVsdDogZGVmYXVsdFZhbHVlID8gREVGQVVMVCA6IHVuZGVmaW5lZCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG4gIGNvbnN0IHByZXZQYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSBoYXNQcmV2VmFsdWUgPyB7W1BBUkFNXTogJ0Zvbyd9IDoge307XG4gIGNvbnN0IHN0YWNrUGFyYW1zID0gIHBhcmFtcy5kaWZmKHsgW1BBUkFNXTogb3ZlcnJpZGUgPyBPVkVSUklERSA6IHVuZGVmaW5lZCB9LCBwcmV2UGFyYW1zKTtcblxuICByZXR1cm4geyBhcGlQYXJhbWV0ZXJzOiBzdGFja1BhcmFtcy5hcGlQYXJhbWV0ZXJzLCBjaGFuZ2VkOiBzdGFja1BhcmFtcy5jaGFuZ2VkIH07XG59Il19