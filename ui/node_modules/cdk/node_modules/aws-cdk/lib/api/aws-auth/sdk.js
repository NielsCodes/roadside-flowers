"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDK = void 0;
const AWS = require("aws-sdk");
const logging_1 = require("../../logging");
const functions_1 = require("../../util/functions");
const account_cache_1 = require("./account-cache");
/**
 * Base functionality of SDK without credential fetching
 */
class SDK {
    constructor(credentials, region, httpOptions = {}) {
        this.credentials = credentials;
        /**
         * Default retry options for SDK clients.
         */
        this.retryOptions = { maxRetries: 6, retryDelayOptions: { base: 300 } };
        /**
         * The more generous retry policy for CloudFormation, which has a 1 TPM limit on certain APIs,
         * which are abundantly used for deployment tracking, ...
         *
         * So we're allowing way more retries, but waiting a bit more.
         */
        this.cloudFormationRetryOptions = { maxRetries: 10, retryDelayOptions: { base: 1000 } };
        this.config = {
            ...httpOptions,
            ...this.retryOptions,
            credentials,
            region,
            logger: { log: (...messages) => messages.forEach(m => logging_1.trace('%s', m)) },
        };
        this.currentRegion = region;
    }
    cloudFormation() {
        return wrapServiceErrorHandling(new AWS.CloudFormation({
            ...this.config,
            ...this.cloudFormationRetryOptions,
        }));
    }
    ec2() {
        return wrapServiceErrorHandling(new AWS.EC2(this.config));
    }
    ssm() {
        return wrapServiceErrorHandling(new AWS.SSM(this.config));
    }
    s3() {
        return wrapServiceErrorHandling(new AWS.S3(this.config));
    }
    route53() {
        return wrapServiceErrorHandling(new AWS.Route53(this.config));
    }
    ecr() {
        return wrapServiceErrorHandling(new AWS.ECR(this.config));
    }
    async currentAccount() {
        return functions_1.cached(this, CURRENT_ACCOUNT_KEY, () => SDK.accountCache.fetch(this.credentials.accessKeyId, async () => {
            // if we don't have one, resolve from STS and store in cache.
            logging_1.debug('Looking up default account ID from STS');
            const result = await new AWS.STS(this.config).getCallerIdentity().promise();
            const accountId = result.Account;
            const partition = result.Arn.split(':')[1];
            if (!accountId) {
                throw new Error('STS didn\'t return an account ID');
            }
            logging_1.debug('Default account ID:', accountId);
            return { accountId, partition };
        }));
    }
}
exports.SDK = SDK;
SDK.accountCache = new account_cache_1.AccountAccessKeyCache();
/**
 * Return a wrapping object for the underlying service object
 *
 * Responds to failures in the underlying service calls, in two different
 * ways:
 *
 * - When errors are encountered, log the failing call and the error that
 *   it triggered (at debug level). This is necessary because the lack of
 *   stack traces in NodeJS otherwise makes it very hard to suss out where
 *   a certain AWS error occurred.
 * - The JS SDK has a funny business of wrapping any credential-based error
 *   in a super-generic (and in our case wrong) exception. If we then use a
 *   'ChainableTemporaryCredentials' and the target role doesn't exist,
 *   the error message that shows up by default is super misleading
 *   (https://github.com/aws/aws-sdk-js/issues/3272). We can fix this because
 *   the exception contains the "inner exception", so we unwrap and throw
 *   the correct error ("cannot assume role").
 *
 * The wrapping business below is slightly more complicated than you'd think
 * because we must hook into the `promise()` method of the object that's being
 * returned from the methods of the object that we wrap, so there's two
 * levels of wrapping going on, and also some exceptions to the wrapping magic.
 */
function wrapServiceErrorHandling(serviceObject) {
    const classObject = serviceObject.constructor.prototype;
    return new Proxy(serviceObject, {
        get(obj, prop) {
            const real = obj[prop];
            // Things we don't want to intercept:
            // - Anything that's not a function.
            // - 'constructor', s3.upload() will use this to do some magic and we need the underlying constructor.
            // - Any method that's not on the service class (do not intercept 'makeRequest' and other helpers).
            if (prop === 'constructor' || !classObject.hasOwnProperty(prop) || !isFunction(real)) {
                return real;
            }
            // NOTE: This must be a function() and not an () => {
            // because I need 'this' to be dynamically bound and not statically bound.
            // If your linter complains don't listen to it!
            return function () {
                // Call the underlying function. If it returns an object with a promise()
                // method on it, wrap that 'promise' method.
                const args = [].slice.call(arguments, 0);
                const response = real.apply(this, args);
                // Don't intercept unless the return value is an object with a '.promise()' method.
                if (typeof response !== 'object' || !response) {
                    return response;
                }
                if (!('promise' in response)) {
                    return response;
                }
                // Return an object with the promise method replaced with a wrapper which will
                // do additional things to errors.
                return Object.assign(Object.create(response), {
                    promise() {
                        return response.promise().catch((e) => {
                            e = makeDetailedException(e);
                            logging_1.debug(`Call failed: ${prop}(${JSON.stringify(args[0])}) => ${e.message}`);
                            return Promise.reject(e); // Re-'throw' the new error
                        });
                    },
                });
            };
        },
    });
}
const CURRENT_ACCOUNT_KEY = Symbol('current_account_key');
function isFunction(x) {
    return x && {}.toString.call(x) === '[object Function]';
}
/**
 * Extract a more detailed error out of a generic error if we can
 */
function makeDetailedException(e) {
    // This is the super-generic "something's wrong" error that the JS SDK wraps other errors in.
    // https://github.com/aws/aws-sdk-js/blob/f0ac2e53457c7512883d0677013eacaad6cd8a19/lib/event_listeners.js#L84
    if (typeof e.message === 'string' && e.message.startsWith('Missing credentials in config')) {
        const original = e.originalError;
        if (original) {
            // When the SDK does a 'util.copy', they lose the Error-ness of the inner error
            // (they copy the Error's properties into a plain object) so make it an Error object again.
            e = Object.assign(new Error(), original);
        }
    }
    // At this point, the error might still be a generic "ChainableTemporaryCredentials failed"
    // error which wraps the REAL error (AssumeRole failed). We're going to replace the error
    // message with one that's more likely to help users, and tell them the most probable
    // fix (bootstrapping). The underlying service call failure will be appended below.
    if (e.message === 'Could not load credentials from ChainableTemporaryCredentials') {
        e.message = 'Could not assume role in target account (did you bootstrap the environment with the right \'--trust\'s?)';
    }
    // Replace the message on this error with a concatenation of all inner error messages.
    // Must more clear what's going on that way.
    e.message = allChainedExceptionMessages(e);
    return e;
}
/**
 * Return the concatenated message of all exceptions in the AWS exception chain
 */
function allChainedExceptionMessages(e) {
    const ret = new Array();
    while (e) {
        ret.push(e.message);
        e = e.originalError;
    }
    return ret.join(': ');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUUvQiwyQ0FBNkM7QUFDN0Msb0RBQThDO0FBQzlDLG1EQUF3RDtBQTZCeEQ7O0dBRUc7QUFDSCxNQUFhLEdBQUc7SUFvQmQsWUFBNkIsV0FBNEIsRUFBRSxNQUFjLEVBQUUsY0FBb0MsRUFBRTtRQUFwRixnQkFBVyxHQUFYLFdBQVcsQ0FBaUI7UUFiekQ7O1dBRUc7UUFDYyxpQkFBWSxHQUFHLEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSxpQkFBaUIsRUFBRSxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsRUFBRSxDQUFDO1FBRXBGOzs7OztXQUtHO1FBQ2MsK0JBQTBCLEdBQUcsRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLGlCQUFpQixFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUssRUFBRSxFQUFFLENBQUM7UUFHbkcsSUFBSSxDQUFDLE1BQU0sR0FBRztZQUNaLEdBQUcsV0FBVztZQUNkLEdBQUcsSUFBSSxDQUFDLFlBQVk7WUFDcEIsV0FBVztZQUNYLE1BQU07WUFDTixNQUFNLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxHQUFHLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLGVBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRTtTQUN4RSxDQUFDO1FBQ0YsSUFBSSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUM7SUFDOUIsQ0FBQztJQUVNLGNBQWM7UUFDbkIsT0FBTyx3QkFBd0IsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxjQUFjLENBQUM7WUFDckQsR0FBRyxJQUFJLENBQUMsTUFBTTtZQUNkLEdBQUcsSUFBSSxDQUFDLDBCQUEwQjtTQUNuQyxDQUFDLENBQUMsQ0FBQztJQUNOLENBQUM7SUFFTSxHQUFHO1FBQ1IsT0FBTyx3QkFBd0Is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QUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLCtCQUErQixDQUFDLEVBQUU7UUFDMUYsTUFBTSxRQUFRLEdBQUksQ0FBUyxDQUFDLGFBQWEsQ0FBQztRQUMxQyxJQUFJLFFBQVEsRUFBRTtZQUNaLCtFQUErRTtZQUMvRSwyRkFBMkY7WUFDM0YsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQztTQUMxQztLQUNGO0lBRUQsMkZBQTJGO0lBQzNGLHlGQUF5RjtJQUN6RixxRkFBcUY7SUFDckYsbUZBQW1GO0lBQ25GLElBQUksQ0FBQyxDQUFDLE9BQU8sS0FBSywrREFBK0QsRUFBRTtRQUNqRixDQUFDLENBQUMsT0FBTyxHQUFHLDBHQUEwRyxDQUFDO0tBQ3hIO0lBRUQsc0ZBQXNGO0lBQ3RGLDRDQUE0QztJQUM1QyxDQUFDLENBQUMsT0FBTyxHQUFHLDJCQUEyQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNDLE9BQU8sQ0FBQyxDQUFDO0FBQ1gsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUywyQkFBMkIsQ0FBQyxDQUFvQjtJQUN2RCxNQUFNLEdBQUcsR0FBRyxJQUFJLEtBQUssRUFBVSxDQUFDO0lBQ2hDLE9BQU8sQ0FBQyxFQUFFO1FBQ1IsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDcEIsQ0FBQyxHQUFJLENBQVMsQ0FBQyxhQUFhLENBQUM7S0FDOUI7SUFDRCxPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDeEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IENvbmZpZ3VyYXRpb25PcHRpb25zIH0gZnJvbSAnYXdzLXNkay9saWIvY29uZmlnJztcbmltcG9ydCB7IGRlYnVnLCB0cmFjZSB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgY2FjaGVkIH0gZnJvbSAnLi4vLi4vdXRpbC9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgQWNjb3VudEFjY2Vzc0tleUNhY2hlIH0gZnJvbSAnLi9hY2NvdW50LWNhY2hlJztcbmltcG9ydCB7IEFjY291bnQgfSBmcm9tICcuL3Nkay1wcm92aWRlcic7XG5cbi8qKiBAZXhwZXJpbWVudGFsICovXG5leHBvcnQgaW50ZXJmYWNlIElTREsge1xuICAvKipcbiAgICogVGhlIHJlZ2lvbiB0aGlzIFNESyBoYXMgYmVlbiBpbnN0YW50aWF0ZWQgZm9yXG4gICAqXG4gICAqIChBcyBkaXN0aW5jdCBmcm9tIHRoZSBgZGVmYXVsdFJlZ2lvbigpYCBvbiBTZGtQcm92aWRlciB3aGljaFxuICAgKiByZXByZXNlbnRzIHRoZSByZWdpb24gY29uZmlndXJlZCBpbiB0aGUgZGVmYXVsdCBjb25maWcpLlxuICAgKi9cbiAgcmVhZG9ubHkgY3VycmVudFJlZ2lvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgQWNjb3VudCB0aGlzIFNESyBoYXMgYmVlbiBpbnN0YW50aWF0ZWQgZm9yXG4gICAqXG4gICAqIChBcyBkaXN0aW5jdCBmcm9tIHRoZSBgZGVmYXVsdEFjY291bnQoKWAgb24gU2RrUHJvdmlkZXIgd2hpY2hcbiAgICogcmVwcmVzZW50cyB0aGUgYWNjb3VudCBhdmFpbGFibGUgYnkgdXNpbmcgZGVmYXVsdCBjcmVkZW50aWFscykuXG4gICAqL1xuICBjdXJyZW50QWNjb3VudCgpOiBQcm9taXNlPEFjY291bnQ+O1xuXG4gIGNsb3VkRm9ybWF0aW9uKCk6IEFXUy5DbG91ZEZvcm1hdGlvbjtcbiAgZWMyKCk6IEFXUy5FQzI7XG4gIHNzbSgpOiBBV1MuU1NNO1xuICBzMygpOiBBV1MuUzM7XG4gIHJvdXRlNTMoKTogQVdTLlJvdXRlNTM7XG4gIGVjcigpOiBBV1MuRUNSO1xufVxuXG4vKipcbiAqIEJhc2UgZnVuY3Rpb25hbGl0eSBvZiBTREsgd2l0aG91dCBjcmVkZW50aWFsIGZldGNoaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBTREsgaW1wbGVtZW50cyBJU0RLIHtcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgYWNjb3VudENhY2hlID0gbmV3IEFjY291bnRBY2Nlc3NLZXlDYWNoZSgpO1xuXG4gIHB1YmxpYyByZWFkb25seSBjdXJyZW50UmVnaW9uOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBjb25maWc6IENvbmZpZ3VyYXRpb25PcHRpb25zO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IHJldHJ5IG9wdGlvbnMgZm9yIFNESyBjbGllbnRzLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSByZXRyeU9wdGlvbnMgPSB7IG1heFJldHJpZXM6IDYsIHJldHJ5RGVsYXlPcHRpb25zOiB7IGJhc2U6IDMwMCB9IH07XG5cbiAgLyoqXG4gICAqIFRoZSBtb3JlIGdlbmVyb3VzIHJldHJ5IHBvbGljeSBmb3IgQ2xvdWRGb3JtYXRpb24sIHdoaWNoIGhhcyBhIDEgVFBNIGxpbWl0IG9uIGNlcnRhaW4gQVBJcyxcbiAgICogd2hpY2ggYXJlIGFidW5kYW50bHkgdXNlZCBmb3IgZGVwbG95bWVudCB0cmFja2luZywgLi4uXG4gICAqXG4gICAqIFNvIHdlJ3JlIGFsbG93aW5nIHdheSBtb3JlIHJldHJpZXMsIGJ1dCB3YWl0aW5nIGEgYml0IG1vcmUuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGNsb3VkRm9ybWF0aW9uUmV0cnlPcHRpb25zID0geyBtYXhSZXRyaWVzOiAxMCwgcmV0cnlEZWxheU9wdGlvbnM6IHsgYmFzZTogMV8wMDAgfSB9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgY3JlZGVudGlhbHM6IEFXUy5DcmVkZW50aWFscywgcmVnaW9uOiBzdHJpbmcsIGh0dHBPcHRpb25zOiBDb25maWd1cmF0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAuLi5odHRwT3B0aW9ucyxcbiAgICAgIC4uLnRoaXMucmV0cnlPcHRpb25zLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICByZWdpb24sXG4gICAgICBsb2dnZXI6IHsgbG9nOiAoLi4ubWVzc2FnZXMpID0+IG1lc3NhZ2VzLmZvckVhY2gobSA9PiB0cmFjZSgnJXMnLCBtKSkgfSxcbiAgICB9O1xuICAgIHRoaXMuY3VycmVudFJlZ2lvbiA9IHJlZ2lvbjtcbiAgfVxuXG4gIHB1YmxpYyBjbG91ZEZvcm1hdGlvbigpOiBBV1MuQ2xvdWRGb3JtYXRpb24ge1xuICAgIHJldHVybiB3cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5DbG91ZEZvcm1hdGlvbih7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIC4uLnRoaXMuY2xvdWRGb3JtYXRpb25SZXRyeU9wdGlvbnMsXG4gICAgfSkpO1xuICB9XG5cbiAgcHVibGljIGVjMigpOiBBV1MuRUMyIHtcbiAgICByZXR1cm4gd3JhcFNlcnZpY2VFcnJvckhhbmRsaW5nKG5ldyBBV1MuRUMyKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgc3NtKCk6IEFXUy5TU00ge1xuICAgIHJldHVybiB3cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5TU00odGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBzMygpOiBBV1MuUzMge1xuICAgIHJldHVybiB3cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5TMyh0aGlzLmNvbmZpZykpO1xuICB9XG5cbiAgcHVibGljIHJvdXRlNTMoKTogQVdTLlJvdXRlNTMge1xuICAgIHJldHVybiB3cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5Sb3V0ZTUzKHRoaXMuY29uZmlnKSk7XG4gIH1cblxuICBwdWJsaWMgZWNyKCk6IEFXUy5FQ1Ige1xuICAgIHJldHVybiB3cmFwU2VydmljZUVycm9ySGFuZGxpbmcobmV3IEFXUy5FQ1IodGhpcy5jb25maWcpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjdXJyZW50QWNjb3VudCgpOiBQcm9taXNlPEFjY291bnQ+IHtcbiAgICByZXR1cm4gY2FjaGVkKHRoaXMsIENVUlJFTlRfQUNDT1VOVF9LRVksICgpID0+IFNESy5hY2NvdW50Q2FjaGUuZmV0Y2godGhpcy5jcmVkZW50aWFscy5hY2Nlc3NLZXlJZCwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBvbmUsIHJlc29sdmUgZnJvbSBTVFMgYW5kIHN0b3JlIGluIGNhY2hlLlxuICAgICAgZGVidWcoJ0xvb2tpbmcgdXAgZGVmYXVsdCBhY2NvdW50IElEIGZyb20gU1RTJyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgQVdTLlNUUyh0aGlzLmNvbmZpZykuZ2V0Q2FsbGVySWRlbnRpdHkoKS5wcm9taXNlKCk7XG4gICAgICBjb25zdCBhY2NvdW50SWQgPSByZXN1bHQuQWNjb3VudDtcbiAgICAgIGNvbnN0IHBhcnRpdGlvbiA9IHJlc3VsdC5Bcm4hLnNwbGl0KCc6JylbMV07XG4gICAgICBpZiAoIWFjY291bnRJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NUUyBkaWRuXFwndCByZXR1cm4gYW4gYWNjb3VudCBJRCcpO1xuICAgICAgfVxuICAgICAgZGVidWcoJ0RlZmF1bHQgYWNjb3VudCBJRDonLCBhY2NvdW50SWQpO1xuICAgICAgcmV0dXJuIHsgYWNjb3VudElkLCBwYXJ0aXRpb24gfTtcbiAgICB9KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gYSB3cmFwcGluZyBvYmplY3QgZm9yIHRoZSB1bmRlcmx5aW5nIHNlcnZpY2Ugb2JqZWN0XG4gKlxuICogUmVzcG9uZHMgdG8gZmFpbHVyZXMgaW4gdGhlIHVuZGVybHlpbmcgc2VydmljZSBjYWxscywgaW4gdHdvIGRpZmZlcmVudFxuICogd2F5czpcbiAqXG4gKiAtIFdoZW4gZXJyb3JzIGFyZSBlbmNvdW50ZXJlZCwgbG9nIHRoZSBmYWlsaW5nIGNhbGwgYW5kIHRoZSBlcnJvciB0aGF0XG4gKiAgIGl0IHRyaWdnZXJlZCAoYXQgZGVidWcgbGV2ZWwpLiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBsYWNrIG9mXG4gKiAgIHN0YWNrIHRyYWNlcyBpbiBOb2RlSlMgb3RoZXJ3aXNlIG1ha2VzIGl0IHZlcnkgaGFyZCB0byBzdXNzIG91dCB3aGVyZVxuICogICBhIGNlcnRhaW4gQVdTIGVycm9yIG9jY3VycmVkLlxuICogLSBUaGUgSlMgU0RLIGhhcyBhIGZ1bm55IGJ1c2luZXNzIG9mIHdyYXBwaW5nIGFueSBjcmVkZW50aWFsLWJhc2VkIGVycm9yXG4gKiAgIGluIGEgc3VwZXItZ2VuZXJpYyAoYW5kIGluIG91ciBjYXNlIHdyb25nKSBleGNlcHRpb24uIElmIHdlIHRoZW4gdXNlIGFcbiAqICAgJ0NoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzJyBhbmQgdGhlIHRhcmdldCByb2xlIGRvZXNuJ3QgZXhpc3QsXG4gKiAgIHRoZSBlcnJvciBtZXNzYWdlIHRoYXQgc2hvd3MgdXAgYnkgZGVmYXVsdCBpcyBzdXBlciBtaXNsZWFkaW5nXG4gKiAgIChodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1zZGstanMvaXNzdWVzLzMyNzIpLiBXZSBjYW4gZml4IHRoaXMgYmVjYXVzZVxuICogICB0aGUgZXhjZXB0aW9uIGNvbnRhaW5zIHRoZSBcImlubmVyIGV4Y2VwdGlvblwiLCBzbyB3ZSB1bndyYXAgYW5kIHRocm93XG4gKiAgIHRoZSBjb3JyZWN0IGVycm9yIChcImNhbm5vdCBhc3N1bWUgcm9sZVwiKS5cbiAqXG4gKiBUaGUgd3JhcHBpbmcgYnVzaW5lc3MgYmVsb3cgaXMgc2xpZ2h0bHkgbW9yZSBjb21wbGljYXRlZCB0aGFuIHlvdSdkIHRoaW5rXG4gKiBiZWNhdXNlIHdlIG11c3QgaG9vayBpbnRvIHRoZSBgcHJvbWlzZSgpYCBtZXRob2Qgb2YgdGhlIG9iamVjdCB0aGF0J3MgYmVpbmdcbiAqIHJldHVybmVkIGZyb20gdGhlIG1ldGhvZHMgb2YgdGhlIG9iamVjdCB0aGF0IHdlIHdyYXAsIHNvIHRoZXJlJ3MgdHdvXG4gKiBsZXZlbHMgb2Ygd3JhcHBpbmcgZ29pbmcgb24sIGFuZCBhbHNvIHNvbWUgZXhjZXB0aW9ucyB0byB0aGUgd3JhcHBpbmcgbWFnaWMuXG4gKi9cbmZ1bmN0aW9uIHdyYXBTZXJ2aWNlRXJyb3JIYW5kbGluZzxBIGV4dGVuZHMgb2JqZWN0PihzZXJ2aWNlT2JqZWN0OiBBKTogQSB7XG4gIGNvbnN0IGNsYXNzT2JqZWN0ID0gc2VydmljZU9iamVjdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgcmV0dXJuIG5ldyBQcm94eShzZXJ2aWNlT2JqZWN0LCB7XG4gICAgZ2V0KG9iajogQSwgcHJvcDogc3RyaW5nKSB7XG4gICAgICBjb25zdCByZWFsID0gKG9iaiBhcyBhbnkpW3Byb3BdO1xuICAgICAgLy8gVGhpbmdzIHdlIGRvbid0IHdhbnQgdG8gaW50ZXJjZXB0OlxuICAgICAgLy8gLSBBbnl0aGluZyB0aGF0J3Mgbm90IGEgZnVuY3Rpb24uXG4gICAgICAvLyAtICdjb25zdHJ1Y3RvcicsIHMzLnVwbG9hZCgpIHdpbGwgdXNlIHRoaXMgdG8gZG8gc29tZSBtYWdpYyBhbmQgd2UgbmVlZCB0aGUgdW5kZXJseWluZyBjb25zdHJ1Y3Rvci5cbiAgICAgIC8vIC0gQW55IG1ldGhvZCB0aGF0J3Mgbm90IG9uIHRoZSBzZXJ2aWNlIGNsYXNzIChkbyBub3QgaW50ZXJjZXB0ICdtYWtlUmVxdWVzdCcgYW5kIG90aGVyIGhlbHBlcnMpLlxuICAgICAgaWYgKHByb3AgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWNsYXNzT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3ApIHx8ICFpc0Z1bmN0aW9uKHJlYWwpKSB7IHJldHVybiByZWFsOyB9XG5cbiAgICAgIC8vIE5PVEU6IFRoaXMgbXVzdCBiZSBhIGZ1bmN0aW9uKCkgYW5kIG5vdCBhbiAoKSA9PiB7XG4gICAgICAvLyBiZWNhdXNlIEkgbmVlZCAndGhpcycgdG8gYmUgZHluYW1pY2FsbHkgYm91bmQgYW5kIG5vdCBzdGF0aWNhbGx5IGJvdW5kLlxuICAgICAgLy8gSWYgeW91ciBsaW50ZXIgY29tcGxhaW5zIGRvbid0IGxpc3RlbiB0byBpdCFcbiAgICAgIHJldHVybiBmdW5jdGlvbih0aGlzOiBhbnkpIHtcbiAgICAgICAgLy8gQ2FsbCB0aGUgdW5kZXJseWluZyBmdW5jdGlvbi4gSWYgaXQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhIHByb21pc2UoKVxuICAgICAgICAvLyBtZXRob2Qgb24gaXQsIHdyYXAgdGhhdCAncHJvbWlzZScgbWV0aG9kLlxuICAgICAgICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHJlYWwuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgLy8gRG9uJ3QgaW50ZXJjZXB0IHVubGVzcyB0aGUgcmV0dXJuIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGEgJy5wcm9taXNlKCknIG1ldGhvZC5cbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZSAhPT0gJ29iamVjdCcgfHwgIXJlc3BvbnNlKSB7IHJldHVybiByZXNwb25zZTsgfVxuICAgICAgICBpZiAoISgncHJvbWlzZScgaW4gcmVzcG9uc2UpKSB7IHJldHVybiByZXNwb25zZTsgfVxuXG4gICAgICAgIC8vIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvbWlzZSBtZXRob2QgcmVwbGFjZWQgd2l0aCBhIHdyYXBwZXIgd2hpY2ggd2lsbFxuICAgICAgICAvLyBkbyBhZGRpdGlvbmFsIHRoaW5ncyB0byBlcnJvcnMuXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUocmVzcG9uc2UpLCB7XG4gICAgICAgICAgcHJvbWlzZSgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5wcm9taXNlKCkuY2F0Y2goKGU6IEVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIGUgPSBtYWtlRGV0YWlsZWRFeGNlcHRpb24oZSk7XG4gICAgICAgICAgICAgIGRlYnVnKGBDYWxsIGZhaWxlZDogJHtwcm9wfSgke0pTT04uc3RyaW5naWZ5KGFyZ3NbMF0pfSkgPT4gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTsgLy8gUmUtJ3Rocm93JyB0aGUgbmV3IGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSxcbiAgfSk7XG59XG5cbmNvbnN0IENVUlJFTlRfQUNDT1VOVF9LRVkgPSBTeW1ib2woJ2N1cnJlbnRfYWNjb3VudF9rZXknKTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4OiBhbnkpOiB4IGlzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55IHtcbiAgcmV0dXJuIHggJiYge30udG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgbW9yZSBkZXRhaWxlZCBlcnJvciBvdXQgb2YgYSBnZW5lcmljIGVycm9yIGlmIHdlIGNhblxuICovXG5mdW5jdGlvbiBtYWtlRGV0YWlsZWRFeGNlcHRpb24oZTogRXJyb3IpOiBFcnJvciB7XG4gIC8vIFRoaXMgaXMgdGhlIHN1cGVyLWdlbmVyaWMgXCJzb21ldGhpbmcncyB3cm9uZ1wiIGVycm9yIHRoYXQgdGhlIEpTIFNESyB3cmFwcyBvdGhlciBlcnJvcnMgaW4uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLXNkay1qcy9ibG9iL2YwYWMyZTUzNDU3Yzc1MTI4ODNkMDY3NzAxM2VhY2FhZDZjZDhhMTkvbGliL2V2ZW50X2xpc3RlbmVycy5qcyNMODRcbiAgaWYgKHR5cGVvZiBlLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIGUubWVzc2FnZS5zdGFydHNXaXRoKCdNaXNzaW5nIGNyZWRlbnRpYWxzIGluIGNvbmZpZycpKSB7XG4gICAgY29uc3Qgb3JpZ2luYWwgPSAoZSBhcyBhbnkpLm9yaWdpbmFsRXJyb3I7XG4gICAgaWYgKG9yaWdpbmFsKSB7XG4gICAgICAvLyBXaGVuIHRoZSBTREsgZG9lcyBhICd1dGlsLmNvcHknLCB0aGV5IGxvc2UgdGhlIEVycm9yLW5lc3Mgb2YgdGhlIGlubmVyIGVycm9yXG4gICAgICAvLyAodGhleSBjb3B5IHRoZSBFcnJvcidzIHByb3BlcnRpZXMgaW50byBhIHBsYWluIG9iamVjdCkgc28gbWFrZSBpdCBhbiBFcnJvciBvYmplY3QgYWdhaW4uXG4gICAgICBlID0gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoKSwgb3JpZ2luYWwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBlcnJvciBtaWdodCBzdGlsbCBiZSBhIGdlbmVyaWMgXCJDaGFpbmFibGVUZW1wb3JhcnlDcmVkZW50aWFscyBmYWlsZWRcIlxuICAvLyBlcnJvciB3aGljaCB3cmFwcyB0aGUgUkVBTCBlcnJvciAoQXNzdW1lUm9sZSBmYWlsZWQpLiBXZSdyZSBnb2luZyB0byByZXBsYWNlIHRoZSBlcnJvclxuICAvLyBtZXNzYWdlIHdpdGggb25lIHRoYXQncyBtb3JlIGxpa2VseSB0byBoZWxwIHVzZXJzLCBhbmQgdGVsbCB0aGVtIHRoZSBtb3N0IHByb2JhYmxlXG4gIC8vIGZpeCAoYm9vdHN0cmFwcGluZykuIFRoZSB1bmRlcmx5aW5nIHNlcnZpY2UgY2FsbCBmYWlsdXJlIHdpbGwgYmUgYXBwZW5kZWQgYmVsb3cuXG4gIGlmIChlLm1lc3NhZ2UgPT09ICdDb3VsZCBub3QgbG9hZCBjcmVkZW50aWFscyBmcm9tIENoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzJykge1xuICAgIGUubWVzc2FnZSA9ICdDb3VsZCBub3QgYXNzdW1lIHJvbGUgaW4gdGFyZ2V0IGFjY291bnQgKGRpZCB5b3UgYm9vdHN0cmFwIHRoZSBlbnZpcm9ubWVudCB3aXRoIHRoZSByaWdodCBcXCctLXRydXN0XFwncz8pJztcbiAgfVxuXG4gIC8vIFJlcGxhY2UgdGhlIG1lc3NhZ2Ugb24gdGhpcyBlcnJvciB3aXRoIGEgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5uZXIgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIE11c3QgbW9yZSBjbGVhciB3aGF0J3MgZ29pbmcgb24gdGhhdCB3YXkuXG4gIGUubWVzc2FnZSA9IGFsbENoYWluZWRFeGNlcHRpb25NZXNzYWdlcyhlKTtcbiAgcmV0dXJuIGU7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBjb25jYXRlbmF0ZWQgbWVzc2FnZSBvZiBhbGwgZXhjZXB0aW9ucyBpbiB0aGUgQVdTIGV4Y2VwdGlvbiBjaGFpblxuICovXG5mdW5jdGlvbiBhbGxDaGFpbmVkRXhjZXB0aW9uTWVzc2FnZXMoZTogRXJyb3IgfCB1bmRlZmluZWQpIHtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5PHN0cmluZz4oKTtcbiAgd2hpbGUgKGUpIHtcbiAgICByZXQucHVzaChlLm1lc3NhZ2UpO1xuICAgIGUgPSAoZSBhcyBhbnkpLm9yaWdpbmFsRXJyb3I7XG4gIH1cbiAgcmV0dXJuIHJldC5qb2luKCc6ICcpO1xufVxuIl19