"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ToolkitInfo = exports.DEFAULT_TOOLKIT_STACK_NAME = void 0;
const colors = require("colors/safe");
const logging_1 = require("../logging");
const bootstrap_1 = require("./bootstrap");
const cloudformation_1 = require("./util/cloudformation");
exports.DEFAULT_TOOLKIT_STACK_NAME = 'CDKToolkit';
/**
 * Information on the Bootstrap stack
 *
 * Called "ToolkitInfo" for historical reasons.
 *
 * @experimental
 */
class ToolkitInfo {
    constructor(props) {
        this.props = props;
        this.sdk = props.sdk;
    }
    static determineName(overrideName) {
        return overrideName !== null && overrideName !== void 0 ? overrideName : exports.DEFAULT_TOOLKIT_STACK_NAME;
    }
    /** @experimental */
    static async lookup(environment, sdk, stackName) {
        var _a;
        const cfn = sdk.cloudFormation();
        const stack = await cloudformation_1.stabilizeStack(cfn, stackName !== null && stackName !== void 0 ? stackName : exports.DEFAULT_TOOLKIT_STACK_NAME);
        if (!stack) {
            logging_1.debug('The environment %s doesn\'t have the CDK toolkit stack (%s) installed. Use %s to setup your environment for use with the toolkit.', environment.name, stackName, colors.blue(`cdk bootstrap "${environment.name}"`));
            return undefined;
        }
        if (stack.stackStatus.isCreationFailure) {
            // Treat a "failed to create" bootstrap stack as an absent one.
            logging_1.debug('The environment %s has a CDK toolkit stack (%s) that failed to create. Use %s to try provisioning it again.', environment.name, stackName, colors.blue(`cdk bootstrap "${environment.name}"`));
            return undefined;
        }
        const outputs = stack.outputs;
        return new ToolkitInfo({
            sdk, environment,
            bucketName: requireOutput(bootstrap_1.BUCKET_NAME_OUTPUT),
            bucketEndpoint: requireOutput(bootstrap_1.BUCKET_DOMAIN_NAME_OUTPUT),
            version: parseInt((_a = outputs[bootstrap_1.BOOTSTRAP_VERSION_OUTPUT]) !== null && _a !== void 0 ? _a : '0', 10),
        });
        function requireOutput(output) {
            if (!(output in outputs)) {
                throw new Error(`The CDK toolkit stack (${stack.stackName}) does not have an output named ${output}. Use 'cdk bootstrap' to correct this.`);
            }
            return outputs[output];
        }
    }
    get bucketUrl() {
        return `https://${this.props.bucketEndpoint}`;
    }
    get bucketName() {
        return this.props.bucketName;
    }
    get version() {
        return this.props.version;
    }
    /**
     * Prepare an ECR repository for uploading to using Docker
     *
     * @experimental
     */
    async prepareEcrRepository(repositoryName) {
        var _a, _b;
        const ecr = await this.ecr();
        // check if repo already exists
        try {
            logging_1.debug(`${repositoryName}: checking if ECR repository already exists`);
            const describeResponse = await ecr.describeRepositories({ repositoryNames: [repositoryName] }).promise();
            const existingRepositoryUri = (_a = describeResponse.repositories[0]) === null || _a === void 0 ? void 0 : _a.repositoryUri;
            if (existingRepositoryUri) {
                return { repositoryUri: existingRepositoryUri };
            }
        }
        catch (e) {
            if (e.code !== 'RepositoryNotFoundException') {
                throw e;
            }
        }
        // create the repo (tag it so it will be easier to garbage collect in the future)
        logging_1.debug(`${repositoryName}: creating ECR repository`);
        const assetTag = { Key: 'awscdk:asset', Value: 'true' };
        const response = await ecr.createRepository({ repositoryName, tags: [assetTag] }).promise();
        const repositoryUri = (_b = response.repository) === null || _b === void 0 ? void 0 : _b.repositoryUri;
        if (!repositoryUri) {
            throw new Error(`CreateRepository did not return a repository URI for ${repositoryUri}`);
        }
        // configure image scanning on push (helps in identifying software vulnerabilities, no additional charge)
        logging_1.debug(`${repositoryName}: enable image scanning`);
        await ecr.putImageScanningConfiguration({ repositoryName, imageScanningConfiguration: { scanOnPush: true } }).promise();
        return { repositoryUri };
    }
    async ecr() {
        return this.sdk.ecr();
    }
}
exports.ToolkitInfo = ToolkitInfo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbGtpdC1pbmZvLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsidG9vbGtpdC1pbmZvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLHNDQUFzQztBQUN0Qyx3Q0FBbUM7QUFFbkMsMkNBQXVHO0FBQ3ZHLDBEQUF1RDtBQUUxQyxRQUFBLDBCQUEwQixHQUFHLFlBQVksQ0FBQztBQUV2RDs7Ozs7O0dBTUc7QUFDSCxNQUFhLFdBQVc7SUF3Q3RCLFlBQTZCLEtBTTVCO1FBTjRCLFVBQUssR0FBTCxLQUFLLENBTWpDO1FBQ0MsSUFBSSxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQ3ZCLENBQUM7SUEvQ00sTUFBTSxDQUFDLGFBQWEsQ0FBQyxZQUFxQjtRQUMvQyxPQUFPLFlBQVksYUFBWixZQUFZLGNBQVosWUFBWSxHQUFJLGtDQUEwQixDQUFDO0lBQ3BELENBQUM7SUFFRCxvQkFBb0I7SUFDYixNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUE4QixFQUFFLEdBQVMsRUFBRSxTQUE2Qjs7UUFDakcsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ2pDLE1BQU0sS0FBSyxHQUFHLE1BQU0sK0JBQWMsQ0FBQyxHQUFHLEVBQUUsU0FBUyxhQUFULFNBQVMsY0FBVCxTQUFTLEdBQUksa0NBQTBCLENBQUMsQ0FBQztRQUNqRixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1YsZUFBSyxDQUFDLG1JQUFtSSxFQUN2SSxXQUFXLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLGtCQUFrQixXQUFXLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQ25GLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsSUFBSSxLQUFLLENBQUMsV0FBVyxDQUFDLGlCQUFpQixFQUFFO1lBQ3ZDLCtEQUErRDtZQUMvRCxlQUFLLENBQUMsNkdBQTZHLEVBQ2pILFdBQVcs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RSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFeEgsT0FBTyxFQUFFLGFBQWEsRUFBRSxDQUFDO0lBQzNCLENBQUM7SUFFTyxLQUFLLENBQUMsR0FBRztRQUNmLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUN4QixDQUFDO0NBQ0Y7QUFyR0Qsa0NBcUdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICdjb2xvcnMvc2FmZSc7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgQk9PVFNUUkFQX1ZFUlNJT05fT1VUUFVULCBCVUNLRVRfRE9NQUlOX05BTUVfT1VUUFVULCBCVUNLRVRfTkFNRV9PVVRQVVQgIH0gZnJvbSAnLi9ib290c3RyYXAnO1xuaW1wb3J0IHsgc3RhYmlsaXplU3RhY2sgfSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUgPSAnQ0RLVG9vbGtpdCc7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gb24gdGhlIEJvb3RzdHJhcCBzdGFja1xuICpcbiAqIENhbGxlZCBcIlRvb2xraXRJbmZvXCIgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjbGFzcyBUb29sa2l0SW5mbyB7XG4gIHB1YmxpYyBzdGF0aWMgZGV0ZXJtaW5lTmFtZShvdmVycmlkZU5hbWU/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVOYW1lID8/IERFRkFVTFRfVE9PTEtJVF9TVEFDS19OQU1FO1xuICB9XG5cbiAgLyoqIEBleHBlcmltZW50YWwgKi9cbiAgcHVibGljIHN0YXRpYyBhc3luYyBsb29rdXAoZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBzZGs6IElTREssIHN0YWNrTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkKTogUHJvbWlzZTxUb29sa2l0SW5mbyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IGNmbiA9IHNkay5jbG91ZEZvcm1hdGlvbigpO1xuICAgIGNvbnN0IHN0YWNrID0gYXdhaXQgc3RhYmlsaXplU3RhY2soY2ZuLCBzdGFja05hbWUgPz8gREVGQVVMVF9UT09MS0lUX1NUQUNLX05BTUUpO1xuICAgIGlmICghc3RhY2spIHtcbiAgICAgIGRlYnVnKCdUaGUgZW52aXJvbm1lbnQgJXMgZG9lc25cXCd0IGhhdmUgdGhlIENESyB0b29sa2l0IHN0YWNrICglcykgaW5zdGFsbGVkLiBVc2UgJXMgdG8gc2V0dXAgeW91ciBlbnZpcm9ubWVudCBmb3IgdXNlIHdpdGggdGhlIHRvb2xraXQuJyxcbiAgICAgICAgZW52aXJvbm1lbnQubmFtZSwgc3RhY2tOYW1lLCBjb2xvcnMuYmx1ZShgY2RrIGJvb3RzdHJhcCBcIiR7ZW52aXJvbm1lbnQubmFtZX1cImApKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChzdGFjay5zdGFja1N0YXR1cy5pc0NyZWF0aW9uRmFpbHVyZSkge1xuICAgICAgLy8gVHJlYXQgYSBcImZhaWxlZCB0byBjcmVhdGVcIiBib290c3RyYXAgc3RhY2sgYXMgYW4gYWJzZW50IG9uZS5cbiAgICAgIGRlYnVnKCdUaGUgZW52aXJvbm1lbnQgJXMgaGFzIGEgQ0RLIHRvb2xraXQgc3RhY2sgKCVzKSB0aGF0IGZhaWxlZCB0byBjcmVhdGUuIFVzZSAlcyB0byB0cnkgcHJvdmlzaW9uaW5nIGl0IGFnYWluLicsXG4gICAgICAgIGVudmlyb25tZW50Lm5hbWUsIHN0YWNrTmFtZSwgY29sb3JzLmJsdWUoYGNkayBib290c3RyYXAgXCIke2Vudmlyb25tZW50Lm5hbWV9XCJgKSk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IG91dHB1dHMgPSBzdGFjay5vdXRwdXRzO1xuXG4gICAgcmV0dXJuIG5ldyBUb29sa2l0SW5mbyh7XG4gICAgICBzZGssIGVudmlyb25tZW50LFxuICAgICAgYnVja2V0TmFtZTogcmVxdWlyZU91dHB1dChCVUNLRVRfTkFNRV9PVVRQVVQpLFxuICAgICAgYnVja2V0RW5kcG9pbnQ6IHJlcXVpcmVPdXRwdXQoQlVDS0VUX0RPTUFJTl9OQU1FX09VVFBVVCksXG4gICAgICB2ZXJzaW9uOiBwYXJzZUludChvdXRwdXRzW0JPT1RTVFJBUF9WRVJTSU9OX09VVFBVVF0gPz8gJzAnLCAxMCksXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiByZXF1aXJlT3V0cHV0KG91dHB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgIGlmICghKG91dHB1dCBpbiBvdXRwdXRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBDREsgdG9vbGtpdCBzdGFjayAoJHtzdGFjayEuc3RhY2tOYW1lfSkgZG9lcyBub3QgaGF2ZSBhbiBvdXRwdXQgbmFtZWQgJHtvdXRwdXR9LiBVc2UgJ2NkayBib290c3RyYXAnIHRvIGNvcnJlY3QgdGhpcy5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXRzW291dHB1dF07XG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlYWRvbmx5IHNkazogSVNESztcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByb3BzOiB7XG4gICAgcmVhZG9ubHkgc2RrOiBJU0RLLFxuICAgIGJ1Y2tldE5hbWU6IHN0cmluZyxcbiAgICBidWNrZXRFbmRwb2ludDogc3RyaW5nLFxuICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCxcbiAgICB2ZXJzaW9uOiBudW1iZXIsXG4gIH0pIHtcbiAgICB0aGlzLnNkayA9IHByb3BzLnNkaztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0VXJsKCkge1xuICAgIHJldHVybiBgaHR0cHM6Ly8ke3RoaXMucHJvcHMuYnVja2V0RW5kcG9pbnR9YDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgYnVja2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wcy5idWNrZXROYW1lO1xuICB9XG5cbiAgcHVibGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BzLnZlcnNpb247XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBhbiBFQ1IgcmVwb3NpdG9yeSBmb3IgdXBsb2FkaW5nIHRvIHVzaW5nIERvY2tlclxuICAgKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgcHJlcGFyZUVjclJlcG9zaXRvcnkocmVwb3NpdG9yeU5hbWU6IHN0cmluZyk6IFByb21pc2U8RWNyUmVwb3NpdG9yeUluZm8+IHtcbiAgICBjb25zdCBlY3IgPSBhd2FpdCB0aGlzLmVjcigpO1xuXG4gICAgLy8gY2hlY2sgaWYgcmVwbyBhbHJlYWR5IGV4aXN0c1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgJHtyZXBvc2l0b3J5TmFtZX06IGNoZWNraW5nIGlmIEVDUiByZXBvc2l0b3J5IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgICBjb25zdCBkZXNjcmliZVJlc3BvbnNlID0gYXdhaXQgZWNyLmRlc2NyaWJlUmVwb3NpdG9yaWVzKHsgcmVwb3NpdG9yeU5hbWVzOiBbcmVwb3NpdG9yeU5hbWVdIH0pLnByb21pc2UoKTtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUmVwb3NpdG9yeVVyaSA9IGRlc2NyaWJlUmVzcG9uc2UucmVwb3NpdG9yaWVzIVswXT8ucmVwb3NpdG9yeVVyaTtcbiAgICAgIGlmIChleGlzdGluZ1JlcG9zaXRvcnlVcmkpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVwb3NpdG9yeVVyaTogZXhpc3RpbmdSZXBvc2l0b3J5VXJpIH07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSAhPT0gJ1JlcG9zaXRvcnlOb3RGb3VuZEV4Y2VwdGlvbicpIHsgdGhyb3cgZTsgfVxuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0aGUgcmVwbyAodGFnIGl0IHNvIGl0IHdpbGwgYmUgZWFzaWVyIHRvIGdhcmJhZ2UgY29sbGVjdCBpbiB0aGUgZnV0dXJlKVxuICAgIGRlYnVnKGAke3JlcG9zaXRvcnlOYW1lfTogY3JlYXRpbmcgRUNSIHJlcG9zaXRvcnlgKTtcbiAgICBjb25zdCBhc3NldFRhZyA9IHsgS2V5OiAnYXdzY2RrOmFzc2V0JywgVmFsdWU6ICd0cnVlJyB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZWNyLmNyZWF0ZVJlcG9zaXRvcnkoeyByZXBvc2l0b3J5TmFtZSwgdGFnczogWyBhc3NldFRhZyBdIH0pLnByb21pc2UoKTtcbiAgICBjb25zdCByZXBvc2l0b3J5VXJpID0gcmVzcG9uc2UucmVwb3NpdG9yeT8ucmVwb3NpdG9yeVVyaTtcbiAgICBpZiAoIXJlcG9zaXRvcnlVcmkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ3JlYXRlUmVwb3NpdG9yeSBkaWQgbm90IHJldHVybiBhIHJlcG9zaXRvcnkgVVJJIGZvciAke3JlcG9zaXRvcnlVcml9YCk7XG4gICAgfVxuXG4gICAgLy8gY29uZmlndXJlIGltYWdlIHNjYW5uaW5nIG9uIHB1c2ggKGhlbHBzIGluIGlkZW50aWZ5aW5nIHNvZnR3YXJlIHZ1bG5lcmFiaWxpdGllcywgbm8gYWRkaXRpb25hbCBjaGFyZ2UpXG4gICAgZGVidWcoYCR7cmVwb3NpdG9yeU5hbWV9OiBlbmFibGUgaW1hZ2Ugc2Nhbm5pbmdgKTtcbiAgICBhd2FpdCBlY3IucHV0SW1hZ2VTY2FubmluZ0NvbmZpZ3VyYXRpb24oeyByZXBvc2l0b3J5TmFtZSwgaW1hZ2VTY2FubmluZ0NvbmZpZ3VyYXRpb246IHsgc2Nhbk9uUHVzaDogdHJ1ZSB9IH0pLnByb21pc2UoKTtcblxuICAgIHJldHVybiB7IHJlcG9zaXRvcnlVcmkgfTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZWNyKCkge1xuICAgIHJldHVybiB0aGlzLnNkay5lY3IoKTtcbiAgfVxufVxuXG4vKiogQGV4cGVyaW1lbnRhbCAqL1xuZXhwb3J0IGludGVyZmFjZSBFY3JSZXBvc2l0b3J5SW5mbyB7XG4gIHJlcG9zaXRvcnlVcmk6IHN0cmluZztcbn1cblxuLyoqIEBleHBlcmltZW50YWwgKi9cbmV4cG9ydCBpbnRlcmZhY2UgRWNyQ3JlZGVudGlhbHMge1xuICB1c2VybmFtZTogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBlbmRwb2ludDogc3RyaW5nO1xufSJdfQ==