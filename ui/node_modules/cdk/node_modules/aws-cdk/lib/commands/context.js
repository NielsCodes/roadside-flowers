"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.realHandler = exports.handler = exports.builder = exports.describe = exports.command = void 0;
const colors = require("colors/safe");
const version = require("../../lib/version");
const logging_1 = require("../logging");
const settings_1 = require("../settings");
const util_1 = require("../util");
exports.command = 'context';
exports.describe = 'Manage cached context values';
exports.builder = {
    reset: {
        alias: 'e',
        desc: 'The context key (or its index) to reset',
        type: 'string',
        requiresArg: true,
    },
    clear: {
        desc: 'Clear all context',
        type: 'boolean',
    },
};
function handler(args) {
    args.commandHandler = realHandler;
}
exports.handler = handler;
async function realHandler(options) {
    const { configuration, args } = options;
    const contextValues = configuration.context.all;
    if (args.clear) {
        configuration.context.clear();
        await configuration.saveContext();
        logging_1.print('All context values cleared.');
    }
    else if (args.reset) {
        invalidateContext(configuration.context, args.reset);
        await configuration.saveContext();
    }
    else {
        // List -- support '--json' flag
        if (args.json) {
            process.stdout.write(JSON.stringify(contextValues, undefined, 2));
        }
        else {
            listContext(contextValues);
        }
    }
    await version.displayVersionMessage();
    return 0;
}
exports.realHandler = realHandler;
function listContext(context) {
    const keys = contextKeys(context);
    if (keys.length === 0) {
        logging_1.print('This CDK application does not have any saved context values yet.');
        logging_1.print('');
        logging_1.print('Context will automatically be saved when you synthesize CDK apps');
        logging_1.print('that use environment context information like AZ information, VPCs,');
        logging_1.print('SSM parameters, and so on.');
        return;
    }
    // Print config by default
    const data = [[colors.green('#'), colors.green('Key'), colors.green('Value')]];
    for (const [i, key] of keys) {
        const jsonWithoutNewlines = JSON.stringify(context[key], undefined, 2).replace(/\s+/g, ' ');
        data.push([i, key, jsonWithoutNewlines]);
    }
    logging_1.print(`Context found in ${colors.blue(settings_1.PROJECT_CONFIG)}:\n`);
    logging_1.print(util_1.renderTable(data, process.stdout.columns));
    // tslint:disable-next-line:max-line-length
    logging_1.print(`Run ${colors.blue('cdk context --reset KEY_OR_NUMBER')} to remove a context key. It will be refreshed on the next CDK synthesis run.`);
}
function invalidateContext(context, key) {
    const i = parseInt(key, 10);
    if (`${i}` === key) {
        // Twas a number and we fully parsed it.
        key = keyByNumber(context, i);
    }
    // Unset!
    if (context.has(key)) {
        context.unset(key);
        logging_1.print(`Context value ${colors.blue(key)} reset. It will be refreshed on next synthesis`);
    }
    else {
        logging_1.print(`No context value with key ${colors.blue(key)}`);
    }
}
function keyByNumber(context, n) {
    for (const [i, key] of contextKeys(context)) {
        if (n === i) {
            return key;
        }
    }
    throw new Error(`No context key with number: ${n}`);
}
/**
 * Return enumerated keys in a definitive order
 */
function contextKeys(context) {
    const keys = Object.keys(context);
    keys.sort();
    return enumerate1(keys);
}
function enumerate1(xs) {
    const ret = new Array();
    let i = 1;
    for (const x of xs) {
        ret.push([i, x]);
        i += 1;
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNvbnRleHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsc0NBQXNDO0FBRXRDLDZDQUE2QztBQUU3Qyx3Q0FBbUM7QUFDbkMsMENBQXNEO0FBQ3RELGtDQUFzQztBQUV6QixRQUFBLE9BQU8sR0FBRyxTQUFTLENBQUM7QUFDcEIsUUFBQSxRQUFRLEdBQUcsOEJBQThCLENBQUM7QUFDMUMsUUFBQSxPQUFPLEdBQUc7SUFDckIsS0FBSyxFQUFFO1FBQ0wsS0FBSyxFQUFFLEdBQUc7UUFDVixJQUFJLEVBQUUseUNBQXlDO1FBQy9DLElBQUksRUFBRSxRQUFRO1FBQ2QsV0FBVyxFQUFFLElBQUk7S0FDbEI7SUFDRCxLQUFLLEVBQUU7UUFDTCxJQUFJLEVBQUUsbUJBQW1CO1FBQ3pCLElBQUksRUFBRSxTQUFTO0tBQ2hCO0NBQ0YsQ0FBQztBQUVGLFNBQWdCLE9BQU8sQ0FBQyxJQUFxQjtJQUMzQyxJQUFJLENBQUMsY0FBYyxHQUFHLFdBQVcsQ0FBQztBQUNwQyxDQUFDO0FBRkQsMEJBRUM7QUFFTSxLQUFLLFVBQVUsV0FBVyxDQUFDLE9BQXVCO0lBQ3ZELE1BQU0sRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDO0lBRXhDLE1BQU0sYUFBYSxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0lBRWhELElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNkLGFBQWEsQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDOUIsTUFBTSxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDbEMsZUFBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7S0FDdEM7U0FBTSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDckIsaUJBQWlCLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsS0FBZSxDQUFDLENBQUM7UUFDL0QsTUFBTSxhQUFhLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDbkM7U0FBTTtRQUNMLGdDQUFnQztRQUNoQyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDYixPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNuRTthQUFNO1lBQ0wsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQzVCO0tBQ0Y7SUFDRCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO0lBRXRDLE9BQU8sQ0FBQyxDQUFDO0FBQ1gsQ0FBQztBQXZCRCxrQ0F1QkM7QUFFRCxTQUFTLFdBQVcsQ0FBQyxPQUFZO0lBQy9CLE1BQU0sSUFBSSxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUVsQyxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLGVBQUssQ0FBQyxrRUFBa0UsQ0FBQyxDQUFDO1FBQzFFLGVBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNWLGVBQUssQ0FBQyxrRUFBa0UsQ0FBQyxDQUFDO1FBQzFFLGVBQUssQ0FBQyxxRUFBcUUsQ0FBQyxDQUFDO1FBQzdFLGVBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1FBRXBDLE9BQU87S0FDUjtJQUVELDBCQUEwQjtJQUMxQixNQUFNLElBQUksR0FBVSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLE1BQU0sQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RGLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxJQUFJLEVBQUU7UUFDM0IsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztRQUM1RixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7S0FDMUM7SUFFRCxlQUFLLENBQUMsb0JBQW9CLE1BQU0sQ0FBQyxJQUFJLENBQUMseUJBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU1RCxlQUFLLENBQUMsa0JBQVcsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBRWpELDJDQUEyQztJQUMzQyxlQUFLLENBQUMsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLG1DQUFtQyxDQUFDLCtFQUErRSxDQUFDLENBQUM7QUFDaEosQ0FBQztBQUVELFNBQVMsaUJBQWlCLENBQUMsT0FBZ0IsRUFBRSxHQUFXO0lBQ3RELE1BQU0sQ0FBQyxHQUFHLFFBQVEsQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDNUIsSUFBSSxHQUFHLENBQUMsRUFBRSxLQUFLLEdBQUcsRUFBRTtRQUNsQix3Q0FBd0M7UUFDeEMsR0FBRyxHQUFHLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDL0I7SUFFRCxTQUFTO0lBQ1QsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3BCLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbkIsZUFBSyxDQUFDLGlCQUFpQixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxnREFBZ0QsQ0FBQyxDQUFDO0tBQzFGO1NBQU07UUFDTCxlQUFLLENBQUMsNkJBQTZCLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ3hEO0FBQ0gsQ0FBQztBQUVELFNBQVMsV0FBVyxDQUFDLE9BQVksRUFBRSxDQUFTO0lBQzFDLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxXQUFXLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDM0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ1gsT0FBTyxHQUFHLENBQUM7U0FDWjtLQUNGO0lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN0RCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLFdBQVcsQ0FBQyxPQUFZO0lBQy9CLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbEMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ1osT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDMUIsQ0FBQztBQUVELFNBQVMsVUFBVSxDQUFJLEVBQU87SUFDNUIsTUFBTSxHQUFHLEdBQUcsSUFBSSxLQUFLLEVBQWUsQ0FBQztJQUNyQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDVixLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUNsQixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakIsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNSO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29sb3JzIGZyb20gJ2NvbG9ycy9zYWZlJztcbmltcG9ydCAqIGFzIHlhcmdzIGZyb20gJ3lhcmdzJztcbmltcG9ydCAqIGFzIHZlcnNpb24gZnJvbSAnLi4vLi4vbGliL3ZlcnNpb24nO1xuaW1wb3J0IHsgQ29tbWFuZE9wdGlvbnMgfSBmcm9tICcuLi9jb21tYW5kLWFwaSc7XG5pbXBvcnQgeyBwcmludCB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgQ29udGV4dCwgUFJPSkVDVF9DT05GSUcgfSBmcm9tICcuLi9zZXR0aW5ncyc7XG5pbXBvcnQgeyByZW5kZXJUYWJsZSB9IGZyb20gJy4uL3V0aWwnO1xuXG5leHBvcnQgY29uc3QgY29tbWFuZCA9ICdjb250ZXh0JztcbmV4cG9ydCBjb25zdCBkZXNjcmliZSA9ICdNYW5hZ2UgY2FjaGVkIGNvbnRleHQgdmFsdWVzJztcbmV4cG9ydCBjb25zdCBidWlsZGVyID0ge1xuICByZXNldDoge1xuICAgIGFsaWFzOiAnZScsXG4gICAgZGVzYzogJ1RoZSBjb250ZXh0IGtleSAob3IgaXRzIGluZGV4KSB0byByZXNldCcsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgcmVxdWlyZXNBcmc6IHRydWUsXG4gIH0sXG4gIGNsZWFyOiB7XG4gICAgZGVzYzogJ0NsZWFyIGFsbCBjb250ZXh0JyxcbiAgICB0eXBlOiAnYm9vbGVhbicsXG4gIH0sXG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlcihhcmdzOiB5YXJncy5Bcmd1bWVudHMpIHtcbiAgYXJncy5jb21tYW5kSGFuZGxlciA9IHJlYWxIYW5kbGVyO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhbEhhbmRsZXIob3B0aW9uczogQ29tbWFuZE9wdGlvbnMpOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCB7IGNvbmZpZ3VyYXRpb24sIGFyZ3MgfSA9IG9wdGlvbnM7XG5cbiAgY29uc3QgY29udGV4dFZhbHVlcyA9IGNvbmZpZ3VyYXRpb24uY29udGV4dC5hbGw7XG5cbiAgaWYgKGFyZ3MuY2xlYXIpIHtcbiAgICBjb25maWd1cmF0aW9uLmNvbnRleHQuY2xlYXIoKTtcbiAgICBhd2FpdCBjb25maWd1cmF0aW9uLnNhdmVDb250ZXh0KCk7XG4gICAgcHJpbnQoJ0FsbCBjb250ZXh0IHZhbHVlcyBjbGVhcmVkLicpO1xuICB9IGVsc2UgaWYgKGFyZ3MucmVzZXQpIHtcbiAgICBpbnZhbGlkYXRlQ29udGV4dChjb25maWd1cmF0aW9uLmNvbnRleHQsIGFyZ3MucmVzZXQgYXMgc3RyaW5nKTtcbiAgICBhd2FpdCBjb25maWd1cmF0aW9uLnNhdmVDb250ZXh0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGlzdCAtLSBzdXBwb3J0ICctLWpzb24nIGZsYWdcbiAgICBpZiAoYXJncy5qc29uKSB7XG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShKU09OLnN0cmluZ2lmeShjb250ZXh0VmFsdWVzLCB1bmRlZmluZWQsIDIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdENvbnRleHQoY29udGV4dFZhbHVlcyk7XG4gICAgfVxuICB9XG4gIGF3YWl0IHZlcnNpb24uZGlzcGxheVZlcnNpb25NZXNzYWdlKCk7XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGxpc3RDb250ZXh0KGNvbnRleHQ6IGFueSkge1xuICBjb25zdCBrZXlzID0gY29udGV4dEtleXMoY29udGV4dCk7XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgcHJpbnQoJ1RoaXMgQ0RLIGFwcGxpY2F0aW9uIGRvZXMgbm90IGhhdmUgYW55IHNhdmVkIGNvbnRleHQgdmFsdWVzIHlldC4nKTtcbiAgICBwcmludCgnJyk7XG4gICAgcHJpbnQoJ0NvbnRleHQgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHNhdmVkIHdoZW4geW91IHN5bnRoZXNpemUgQ0RLIGFwcHMnKTtcbiAgICBwcmludCgndGhhdCB1c2UgZW52aXJvbm1lbnQgY29udGV4dCBpbmZvcm1hdGlvbiBsaWtlIEFaIGluZm9ybWF0aW9uLCBWUENzLCcpO1xuICAgIHByaW50KCdTU00gcGFyYW1ldGVycywgYW5kIHNvIG9uLicpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUHJpbnQgY29uZmlnIGJ5IGRlZmF1bHRcbiAgY29uc3QgZGF0YTogYW55W10gPSBbW2NvbG9ycy5ncmVlbignIycpLCBjb2xvcnMuZ3JlZW4oJ0tleScpLCBjb2xvcnMuZ3JlZW4oJ1ZhbHVlJyldXTtcbiAgZm9yIChjb25zdCBbaSwga2V5XSBvZiBrZXlzKSB7XG4gICAgY29uc3QganNvbldpdGhvdXROZXdsaW5lcyA9IEpTT04uc3RyaW5naWZ5KGNvbnRleHRba2V5XSwgdW5kZWZpbmVkLCAyKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgZGF0YS5wdXNoKFtpLCBrZXksIGpzb25XaXRob3V0TmV3bGluZXNdKTtcbiAgfVxuXG4gIHByaW50KGBDb250ZXh0IGZvdW5kIGluICR7Y29sb3JzLmJsdWUoUFJPSkVDVF9DT05GSUcpfTpcXG5gKTtcblxuICBwcmludChyZW5kZXJUYWJsZShkYXRhLCBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zKSk7XG5cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1saW5lLWxlbmd0aFxuICBwcmludChgUnVuICR7Y29sb3JzLmJsdWUoJ2NkayBjb250ZXh0IC0tcmVzZXQgS0VZX09SX05VTUJFUicpfSB0byByZW1vdmUgYSBjb250ZXh0IGtleS4gSXQgd2lsbCBiZSByZWZyZXNoZWQgb24gdGhlIG5leHQgQ0RLIHN5bnRoZXNpcyBydW4uYCk7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0KGNvbnRleHQ6IENvbnRleHQsIGtleTogc3RyaW5nKSB7XG4gIGNvbnN0IGkgPSBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKGAke2l9YCA9PT0ga2V5KSB7XG4gICAgLy8gVHdhcyBhIG51bWJlciBhbmQgd2UgZnVsbHkgcGFyc2VkIGl0LlxuICAgIGtleSA9IGtleUJ5TnVtYmVyKGNvbnRleHQsIGkpO1xuICB9XG5cbiAgLy8gVW5zZXQhXG4gIGlmIChjb250ZXh0LmhhcyhrZXkpKSB7XG4gICAgY29udGV4dC51bnNldChrZXkpO1xuICAgIHByaW50KGBDb250ZXh0IHZhbHVlICR7Y29sb3JzLmJsdWUoa2V5KX0gcmVzZXQuIEl0IHdpbGwgYmUgcmVmcmVzaGVkIG9uIG5leHQgc3ludGhlc2lzYCk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnQoYE5vIGNvbnRleHQgdmFsdWUgd2l0aCBrZXkgJHtjb2xvcnMuYmx1ZShrZXkpfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGtleUJ5TnVtYmVyKGNvbnRleHQ6IGFueSwgbjogbnVtYmVyKSB7XG4gIGZvciAoY29uc3QgW2ksIGtleV0gb2YgY29udGV4dEtleXMoY29udGV4dCkpIHtcbiAgICBpZiAobiA9PT0gaSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBObyBjb250ZXh0IGtleSB3aXRoIG51bWJlcjogJHtufWApO1xufVxuXG4vKipcbiAqIFJldHVybiBlbnVtZXJhdGVkIGtleXMgaW4gYSBkZWZpbml0aXZlIG9yZGVyXG4gKi9cbmZ1bmN0aW9uIGNvbnRleHRLZXlzKGNvbnRleHQ6IGFueSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY29udGV4dCk7XG4gIGtleXMuc29ydCgpO1xuICByZXR1cm4gZW51bWVyYXRlMShrZXlzKTtcbn1cblxuZnVuY3Rpb24gZW51bWVyYXRlMTxUPih4czogVFtdKTogQXJyYXk8W251bWJlciwgVF0+IHtcbiAgY29uc3QgcmV0ID0gbmV3IEFycmF5PFtudW1iZXIsIFRdPigpO1xuICBsZXQgaSA9IDE7XG4gIGZvciAoY29uc3QgeCBvZiB4cykge1xuICAgIHJldC5wdXNoKFtpLCB4XSk7XG4gICAgaSArPSAxO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iXX0=