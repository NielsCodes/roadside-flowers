"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const update_schema_1 = require("../scripts/update-schema");
test('if this test fails, run "yarn update-schema"', () => {
    // when we compare schemas we ignore changes the
    // description that is generated from the ts docstrings.
    const docStringFields = [
        'description',
    ];
    for (const schemaName of update_schema_1.SCHEMAS) {
        const expected = removeStringKeys(update_schema_1.generateSchema(schemaName, false), docStringFields);
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const actual = removeStringKeys(require(`../schema/${schemaName}.schema.json`), docStringFields);
        try {
            expect(actual).toEqual(expected);
        }
        catch (err) {
            // I couldn't for the life of me figure out how to provide additional error message
            // to jest...any ideas?
            err.message = `Whoops, Looks like the schema has changed. Did you forget to run 'yarn update-schema'?\n\n${err.message}`;
            throw err;
        }
    }
});
function removeStringKeys(obj, keys) {
    function _recurse(o) {
        for (const prop in o) {
            if (keys.includes(prop) && typeof o[prop] === 'string') {
                delete o[prop];
            }
            else if (typeof o[prop] === 'object') {
                _recurse(o[prop]);
            }
        }
    }
    const cloned = clone(obj);
    _recurse(cloned);
    return cloned;
}
function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzY2hlbWEudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDREQUFtRTtBQUVuRSxJQUFJLENBQUMsOENBQThDLEVBQUUsR0FBRyxFQUFFO0lBRXhELGdEQUFnRDtJQUNoRCx3REFBd0Q7SUFDeEQsTUFBTSxlQUFlLEdBQUc7UUFDdEIsYUFBYTtLQUNkLENBQUM7SUFFRixLQUFLLE1BQU0sVUFBVSxJQUFJLHVCQUFPLEVBQUU7UUFDaEMsTUFBTSxRQUFRLEdBQUcsZ0JBQWdCLENBQUMsOEJBQWMsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFFdEYsaUVBQWlFO1FBQ2pFLE1BQU0sTUFBTSxHQUFHLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxhQUFhLFVBQVUsY0FBYyxDQUFDLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFFakcsSUFBSTtZQUNGLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDbEM7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLG1GQUFtRjtZQUNuRix1QkFBdUI7WUFDdkIsR0FBRyxDQUFDLE9BQU8sR0FBRyw2RkFBNkYsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3pILE1BQU0sR0FBRyxDQUFDO1NBQ1g7S0FDRjtBQUVILENBQUMsQ0FBQyxDQUFDO0FBRUgsU0FBUyxnQkFBZ0IsQ0FBQyxHQUFRLEVBQUUsSUFBYztJQUVoRCxTQUFTLFFBQVEsQ0FBQyxDQUFNO1FBQ3RCLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxFQUFFO1lBQ3BCLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxRQUFRLEVBQUU7Z0JBQ3RELE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2hCO2lCQUFNLElBQUksT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssUUFBUSxFQUFFO2dCQUN0QyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDbkI7U0FDRjtJQUNILENBQUM7SUFFRCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDMUIsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRWpCLE9BQU8sTUFBTSxDQUFDO0FBRWhCLENBQUM7QUFFRCxTQUFTLEtBQUssQ0FBQyxHQUFRO0lBQ3JCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDekMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdlbmVyYXRlU2NoZW1hLCBTQ0hFTUFTIH0gZnJvbSAnLi4vc2NyaXB0cy91cGRhdGUtc2NoZW1hJztcblxudGVzdCgnaWYgdGhpcyB0ZXN0IGZhaWxzLCBydW4gXCJ5YXJuIHVwZGF0ZS1zY2hlbWFcIicsICgpID0+IHtcblxuICAvLyB3aGVuIHdlIGNvbXBhcmUgc2NoZW1hcyB3ZSBpZ25vcmUgY2hhbmdlcyB0aGVcbiAgLy8gZGVzY3JpcHRpb24gdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgdHMgZG9jc3RyaW5ncy5cbiAgY29uc3QgZG9jU3RyaW5nRmllbGRzID0gW1xuICAgICdkZXNjcmlwdGlvbicsXG4gIF07XG5cbiAgZm9yIChjb25zdCBzY2hlbWFOYW1lIG9mIFNDSEVNQVMpIHtcbiAgICBjb25zdCBleHBlY3RlZCA9IHJlbW92ZVN0cmluZ0tleXMoZ2VuZXJhdGVTY2hlbWEoc2NoZW1hTmFtZSwgZmFsc2UpLCBkb2NTdHJpbmdGaWVsZHMpO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICBjb25zdCBhY3R1YWwgPSByZW1vdmVTdHJpbmdLZXlzKHJlcXVpcmUoYC4uL3NjaGVtYS8ke3NjaGVtYU5hbWV9LnNjaGVtYS5qc29uYCksIGRvY1N0cmluZ0ZpZWxkcyk7XG5cbiAgICB0cnkge1xuICAgICAgZXhwZWN0KGFjdHVhbCkudG9FcXVhbChleHBlY3RlZCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJIGNvdWxkbid0IGZvciB0aGUgbGlmZSBvZiBtZSBmaWd1cmUgb3V0IGhvdyB0byBwcm92aWRlIGFkZGl0aW9uYWwgZXJyb3IgbWVzc2FnZVxuICAgICAgLy8gdG8gamVzdC4uLmFueSBpZGVhcz9cbiAgICAgIGVyci5tZXNzYWdlID0gYFdob29wcywgTG9va3MgbGlrZSB0aGUgc2NoZW1hIGhhcyBjaGFuZ2VkLiBEaWQgeW91IGZvcmdldCB0byBydW4gJ3lhcm4gdXBkYXRlLXNjaGVtYSc/XFxuXFxuJHtlcnIubWVzc2FnZX1gO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG59KTtcblxuZnVuY3Rpb24gcmVtb3ZlU3RyaW5nS2V5cyhvYmo6IGFueSwga2V5czogc3RyaW5nW10pIHtcblxuICBmdW5jdGlvbiBfcmVjdXJzZShvOiBhbnkpIHtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gbykge1xuICAgICAgaWYgKGtleXMuaW5jbHVkZXMocHJvcCkgJiYgdHlwZW9mIG9bcHJvcF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRlbGV0ZSBvW3Byb3BdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb1twcm9wXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgX3JlY3Vyc2Uob1twcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2xvbmVkID0gY2xvbmUob2JqKTtcbiAgX3JlY3Vyc2UoY2xvbmVkKTtcblxuICByZXR1cm4gY2xvbmVkO1xuXG59XG5cbmZ1bmN0aW9uIGNsb25lKG9iajogYW55KSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuIl19