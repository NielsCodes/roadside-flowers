"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FactName = exports.Fact = void 0;
/**
 * A database of regional information.
 */
class Fact {
    constructor() {
        throw new Error('Use the static methods of Fact instead!');
    }
    /**
     * @returns the list of names of AWS regions for which there is at least one registered fact. This
     *          may not be an exhaustive list of all available AWS regions.
     */
    static get regions() {
        return Object.keys(this.database);
    }
    /**
     * Retrieves a fact from this Fact database.
     *
     * @param region the name of the region (e.g: `us-east-1`)
     * @param name   the name of the fact being looked up (see the `FactName` class for details)
     *
     * @returns the fact value if it is known, and `undefined` otherwise.
     */
    static find(region, name) {
        const regionFacts = this.database[region];
        return regionFacts && regionFacts[name];
    }
    /**
     * Retrieve a fact from the Fact database. (retrieval will fail if the specified region or
     * fact name does not exist.)
     *
     * @param region the name of the region (e.g: `us-east-1`)
     * @param name the name of the fact being looked up (see the `FactName` class for details)
     */
    static requireFact(region, name) {
        const foundFact = this.find(region, name);
        if (!foundFact) {
            throw new Error(`No fact ${name} could be found for region: ${region} and name: ${name}`);
        }
        return foundFact;
    }
    /**
     * Registers a new fact in this Fact database.
     *
     * @param fact           the new fact to be registered.
     * @param allowReplacing whether new facts can replace existing facts or not.
     */
    static register(fact, allowReplacing = false) {
        const regionFacts = this.database[fact.region] || (this.database[fact.region] = {});
        if (fact.name in regionFacts && regionFacts[fact.name] !== fact.value && !allowReplacing) {
            throw new Error(`Region ${fact.region} already has a fact ${fact.name}, with value ${regionFacts[fact.name]}`);
        }
        regionFacts[fact.name] = fact.value;
    }
    /**
     * Removes a fact from the database.
     * @param region the region for which the fact is to be removed.
     * @param name   the name of the fact to remove.
     * @param value  the value that should be removed (removal will fail if the value is specified, but does not match the
     *               current stored value).
     */
    static unregister(region, name, value) {
        const regionFacts = this.database[region] || {};
        if (name in regionFacts && value && regionFacts[name] !== value) {
            throw new Error(`Attempted to remove ${name} from ${region} with value ${value}, but the fact's value is ${regionFacts[name]}`);
        }
        delete regionFacts[name];
    }
}
exports.Fact = Fact;
Fact.database = {};
/**
 * All standardized fact names.
 */
class FactName {
    /**
     * The name of the regional service principal for a given service.
     *
     * @param service the service name, either simple (e.g: `s3`, `codedeploy`) or qualified (e.g: `s3.amazonaws.com`).
     *                The `.amazonaws.com` and `.amazonaws.com.cn` domains are stripped from service names, so they are
     *                canonicalized in that respect.
     */
    static servicePrincipal(service) {
        return `service-principal:${service.replace(/\.amazonaws\.com(\.cn)?$/, '')}`;
    }
}
exports.FactName = FactName;
/**
 * The name of the partition for a region (e.g: 'aws', 'aws-cn', ...)
 */
FactName.PARTITION = 'partition';
/**
 * The domain suffix for a region (e.g: 'amazonaws.com`)
 */
FactName.DOMAIN_SUFFIX = 'domainSuffix';
/**
 * Whether the AWS::CDK::Metadata CloudFormation Resource is available in-region or not. The value is a boolean
 * modelled as `YES` or `NO`.
 */
FactName.CDK_METADATA_RESOURCE_AVAILABLE = 'cdk:metadata-resource:available';
/**
 * The endpoint used for hosting S3 static websites
 */
FactName.S3_STATIC_WEBSITE_ENDPOINT = 's3-static-website:endpoint';
/**
 * The endpoint used for aliasing S3 static websites in Route 53
 */
FactName.S3_STATIC_WEBSITE_ZONE_53_HOSTED_ZONE_ID = 's3-static-website:route-53-hosted-zone-id';
/**
 * The prefix for VPC Endpoint Service names,
 * cn.com.amazonaws.vpce for China regions,
 * com.amazonaws.vpce otherwise.
 */
FactName.VPC_ENDPOINT_SERVICE_NAME_PREFIX = 'vpcEndpointServiceNamePrefix';
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImZhY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0dBRUc7QUFDSCxNQUFhLElBQUk7SUFzRWY7UUFDRSxNQUFNLElBQUksS0FBSyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQXZFRDs7O09BR0c7SUFDSSxNQUFNLEtBQUssT0FBTztRQUN2QixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFjLEVBQUUsSUFBWTtRQUM3QyxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzFDLE9BQU8sV0FBVyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFjLEVBQUUsSUFBWTtRQUNwRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUUxQyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxXQUFXLElBQUksK0JBQStCLE1BQU0sY0FBYyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1NBQzNGO1FBRUQsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0ksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFXLEVBQUUsY0FBYyxHQUFHLEtBQUs7UUFDeEQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztRQUNwRixJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksV0FBVyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUN4RixNQUFNLElBQUksS0FBSyxDQUFDLFVBQVUsSUFBSSxDQUFDLE1BQU0sdUJBQXVCLElBQUksQ0FBQyxJQUFJLGdCQUFnQixXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNoSDtRQUNELFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztJQUN0QyxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ksTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFjLEVBQUUsSUFBWSxFQUFFLEtBQWM7UUFDbkUsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDaEQsSUFBSSxJQUFJLElBQUksV0FBVyxJQUFJLEtBQUssSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssS0FBSyxFQUFFO1lBQy9ELE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLElBQUksU0FBUyxNQUFNLGVBQWUsS0FBSyw2QkFBNkIsV0FBVyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUNqSTtRQUNELE9BQU8sV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNCLENBQUM7O0FBbEVILG9CQXlFQztBQUx5QixhQUFRLEdBQXFELEVBQUUsQ0FBQztBQTJCMUY7O0dBRUc7QUFDSCxNQUFhLFFBQVE7SUFrQ25COzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFlO1FBQzVDLE9BQU8scUJBQXFCLE9BQU8sQ0FBQyxPQUFPLENBQUMsMEJBQTBCLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUNoRixDQUFDOztBQTNDSCw0QkE0Q0M7QUEzQ0M7O0dBRUc7QUFDb0Isa0JBQVMsR0FBRyxXQUFXLENBQUM7QUFFL0M7O0dBRUc7QUFDb0Isc0JBQWEsR0FBRyxjQUFjLENBQUM7QUFFdEQ7OztHQUdHO0FBQ29CLHdDQUErQixHQUFHLGlDQUFpQyxDQUFDO0FBRTNGOztHQUVHO0FBQ29CLG1DQUEwQixHQUFHLDRCQUE0QixDQUFDO0FBRWpGOztHQUVHO0FBQ29CLGlEQUF3QyxHQUFHLDJDQUEyQyxDQUFDO0FBRTlHOzs7O0dBSUc7QUFDb0IseUNBQWdDLEdBQUcsOEJBQThCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgZGF0YWJhc2Ugb2YgcmVnaW9uYWwgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWN0IHtcbiAgLyoqXG4gICAqIEByZXR1cm5zIHRoZSBsaXN0IG9mIG5hbWVzIG9mIEFXUyByZWdpb25zIGZvciB3aGljaCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgcmVnaXN0ZXJlZCBmYWN0LiBUaGlzXG4gICAqICAgICAgICAgIG1heSBub3QgYmUgYW4gZXhoYXVzdGl2ZSBsaXN0IG9mIGFsbCBhdmFpbGFibGUgQVdTIHJlZ2lvbnMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGdldCByZWdpb25zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kYXRhYmFzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgZmFjdCBmcm9tIHRoaXMgRmFjdCBkYXRhYmFzZS5cbiAgICpcbiAgICogQHBhcmFtIHJlZ2lvbiB0aGUgbmFtZSBvZiB0aGUgcmVnaW9uIChlLmc6IGB1cy1lYXN0LTFgKVxuICAgKiBAcGFyYW0gbmFtZSAgIHRoZSBuYW1lIG9mIHRoZSBmYWN0IGJlaW5nIGxvb2tlZCB1cCAoc2VlIHRoZSBgRmFjdE5hbWVgIGNsYXNzIGZvciBkZXRhaWxzKVxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgZmFjdCB2YWx1ZSBpZiBpdCBpcyBrbm93biwgYW5kIGB1bmRlZmluZWRgIG90aGVyd2lzZS5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZmluZChyZWdpb246IHN0cmluZywgbmFtZTogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCByZWdpb25GYWN0cyA9IHRoaXMuZGF0YWJhc2VbcmVnaW9uXTtcbiAgICByZXR1cm4gcmVnaW9uRmFjdHMgJiYgcmVnaW9uRmFjdHNbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYSBmYWN0IGZyb20gdGhlIEZhY3QgZGF0YWJhc2UuIChyZXRyaWV2YWwgd2lsbCBmYWlsIGlmIHRoZSBzcGVjaWZpZWQgcmVnaW9uIG9yXG4gICAqIGZhY3QgbmFtZSBkb2VzIG5vdCBleGlzdC4pXG4gICAqXG4gICAqIEBwYXJhbSByZWdpb24gdGhlIG5hbWUgb2YgdGhlIHJlZ2lvbiAoZS5nOiBgdXMtZWFzdC0xYClcbiAgICogQHBhcmFtIG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZhY3QgYmVpbmcgbG9va2VkIHVwIChzZWUgdGhlIGBGYWN0TmFtZWAgY2xhc3MgZm9yIGRldGFpbHMpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlcXVpcmVGYWN0KHJlZ2lvbjogc3RyaW5nLCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGZvdW5kRmFjdCA9IHRoaXMuZmluZChyZWdpb24sIG5hbWUpO1xuXG4gICAgaWYgKCFmb3VuZEZhY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZmFjdCAke25hbWV9IGNvdWxkIGJlIGZvdW5kIGZvciByZWdpb246ICR7cmVnaW9ufSBhbmQgbmFtZTogJHtuYW1lfWApO1xuICAgIH1cblxuICAgIHJldHVybiBmb3VuZEZhY3Q7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbmV3IGZhY3QgaW4gdGhpcyBGYWN0IGRhdGFiYXNlLlxuICAgKlxuICAgKiBAcGFyYW0gZmFjdCAgICAgICAgICAgdGhlIG5ldyBmYWN0IHRvIGJlIHJlZ2lzdGVyZWQuXG4gICAqIEBwYXJhbSBhbGxvd1JlcGxhY2luZyB3aGV0aGVyIG5ldyBmYWN0cyBjYW4gcmVwbGFjZSBleGlzdGluZyBmYWN0cyBvciBub3QuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlZ2lzdGVyKGZhY3Q6IElGYWN0LCBhbGxvd1JlcGxhY2luZyA9IGZhbHNlKTogdm9pZCB7XG4gICAgY29uc3QgcmVnaW9uRmFjdHMgPSB0aGlzLmRhdGFiYXNlW2ZhY3QucmVnaW9uXSB8fCAodGhpcy5kYXRhYmFzZVtmYWN0LnJlZ2lvbl0gPSB7fSk7XG4gICAgaWYgKGZhY3QubmFtZSBpbiByZWdpb25GYWN0cyAmJiByZWdpb25GYWN0c1tmYWN0Lm5hbWVdICE9PSBmYWN0LnZhbHVlICYmICFhbGxvd1JlcGxhY2luZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWdpb24gJHtmYWN0LnJlZ2lvbn0gYWxyZWFkeSBoYXMgYSBmYWN0ICR7ZmFjdC5uYW1lfSwgd2l0aCB2YWx1ZSAke3JlZ2lvbkZhY3RzW2ZhY3QubmFtZV19YCk7XG4gICAgfVxuICAgIHJlZ2lvbkZhY3RzW2ZhY3QubmFtZV0gPSBmYWN0LnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBmYWN0IGZyb20gdGhlIGRhdGFiYXNlLlxuICAgKiBAcGFyYW0gcmVnaW9uIHRoZSByZWdpb24gZm9yIHdoaWNoIHRoZSBmYWN0IGlzIHRvIGJlIHJlbW92ZWQuXG4gICAqIEBwYXJhbSBuYW1lICAgdGhlIG5hbWUgb2YgdGhlIGZhY3QgdG8gcmVtb3ZlLlxuICAgKiBAcGFyYW0gdmFsdWUgIHRoZSB2YWx1ZSB0aGF0IHNob3VsZCBiZSByZW1vdmVkIChyZW1vdmFsIHdpbGwgZmFpbCBpZiB0aGUgdmFsdWUgaXMgc3BlY2lmaWVkLCBidXQgZG9lcyBub3QgbWF0Y2ggdGhlXG4gICAqICAgICAgICAgICAgICAgY3VycmVudCBzdG9yZWQgdmFsdWUpLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyB1bnJlZ2lzdGVyKHJlZ2lvbjogc3RyaW5nLCBuYW1lOiBzdHJpbmcsIHZhbHVlPzogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgcmVnaW9uRmFjdHMgPSB0aGlzLmRhdGFiYXNlW3JlZ2lvbl0gfHwge307XG4gICAgaWYgKG5hbWUgaW4gcmVnaW9uRmFjdHMgJiYgdmFsdWUgJiYgcmVnaW9uRmFjdHNbbmFtZV0gIT09IHZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byByZW1vdmUgJHtuYW1lfSBmcm9tICR7cmVnaW9ufSB3aXRoIHZhbHVlICR7dmFsdWV9LCBidXQgdGhlIGZhY3QncyB2YWx1ZSBpcyAke3JlZ2lvbkZhY3RzW25hbWVdfWApO1xuICAgIH1cbiAgICBkZWxldGUgcmVnaW9uRmFjdHNbbmFtZV07XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBkYXRhYmFzZTogeyBbcmVnaW9uOiBzdHJpbmddOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfSB9ID0ge307XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZSB0aGUgc3RhdGljIG1ldGhvZHMgb2YgRmFjdCBpbnN0ZWFkIScpO1xuICB9XG59XG5cbi8qKlxuICogQSBmYWN0IHRoYXQgY2FuIGJlIHJlZ2lzdGVyZWQgYWJvdXQgYSBwYXJ0aWN1bGFyIHJlZ2lvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJRmFjdCB7XG4gIC8qKlxuICAgKiBUaGUgcmVnaW9uIGZvciB3aGljaCB0aGlzIGZhY3QgYXBwbGllcy5cbiAgICovXG4gIHJlYWRvbmx5IHJlZ2lvbjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIGZhY3QuIFN0YW5kYXJkaXplZCB2YWx1ZXMgYXJlIHByb3ZpZGVkIGJ5IHRoZSBgRmFjdHNgIGNsYXNzLlxuICAgKi9cbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhpcyBmYWN0LlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBBbGwgc3RhbmRhcmRpemVkIGZhY3QgbmFtZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBGYWN0TmFtZSB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcGFydGl0aW9uIGZvciBhIHJlZ2lvbiAoZS5nOiAnYXdzJywgJ2F3cy1jbicsIC4uLilcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUEFSVElUSU9OID0gJ3BhcnRpdGlvbic7XG5cbiAgLyoqXG4gICAqIFRoZSBkb21haW4gc3VmZml4IGZvciBhIHJlZ2lvbiAoZS5nOiAnYW1hem9uYXdzLmNvbWApXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERPTUFJTl9TVUZGSVggPSAnZG9tYWluU3VmZml4JztcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgQVdTOjpDREs6Ok1ldGFkYXRhIENsb3VkRm9ybWF0aW9uIFJlc291cmNlIGlzIGF2YWlsYWJsZSBpbi1yZWdpb24gb3Igbm90LiBUaGUgdmFsdWUgaXMgYSBib29sZWFuXG4gICAqIG1vZGVsbGVkIGFzIGBZRVNgIG9yIGBOT2AuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IENES19NRVRBREFUQV9SRVNPVVJDRV9BVkFJTEFCTEUgPSAnY2RrOm1ldGFkYXRhLXJlc291cmNlOmF2YWlsYWJsZSc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbmRwb2ludCB1c2VkIGZvciBob3N0aW5nIFMzIHN0YXRpYyB3ZWJzaXRlc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBTM19TVEFUSUNfV0VCU0lURV9FTkRQT0lOVCA9ICdzMy1zdGF0aWMtd2Vic2l0ZTplbmRwb2ludCc7XG5cbiAgLyoqXG4gICAqIFRoZSBlbmRwb2ludCB1c2VkIGZvciBhbGlhc2luZyBTMyBzdGF0aWMgd2Vic2l0ZXMgaW4gUm91dGUgNTNcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgUzNfU1RBVElDX1dFQlNJVEVfWk9ORV81M19IT1NURURfWk9ORV9JRCA9ICdzMy1zdGF0aWMtd2Vic2l0ZTpyb3V0ZS01My1ob3N0ZWQtem9uZS1pZCc7XG5cbiAgLyoqXG4gICAqIFRoZSBwcmVmaXggZm9yIFZQQyBFbmRwb2ludCBTZXJ2aWNlIG5hbWVzLFxuICAgKiBjbi5jb20uYW1hem9uYXdzLnZwY2UgZm9yIENoaW5hIHJlZ2lvbnMsXG4gICAqIGNvbS5hbWF6b25hd3MudnBjZSBvdGhlcndpc2UuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFZQQ19FTkRQT0lOVF9TRVJWSUNFX05BTUVfUFJFRklYID0gJ3ZwY0VuZHBvaW50U2VydmljZU5hbWVQcmVmaXgnO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgcmVnaW9uYWwgc2VydmljZSBwcmluY2lwYWwgZm9yIGEgZ2l2ZW4gc2VydmljZS5cbiAgICpcbiAgICogQHBhcmFtIHNlcnZpY2UgdGhlIHNlcnZpY2UgbmFtZSwgZWl0aGVyIHNpbXBsZSAoZS5nOiBgczNgLCBgY29kZWRlcGxveWApIG9yIHF1YWxpZmllZCAoZS5nOiBgczMuYW1hem9uYXdzLmNvbWApLlxuICAgKiAgICAgICAgICAgICAgICBUaGUgYC5hbWF6b25hd3MuY29tYCBhbmQgYC5hbWF6b25hd3MuY29tLmNuYCBkb21haW5zIGFyZSBzdHJpcHBlZCBmcm9tIHNlcnZpY2UgbmFtZXMsIHNvIHRoZXkgYXJlXG4gICAqICAgICAgICAgICAgICAgIGNhbm9uaWNhbGl6ZWQgaW4gdGhhdCByZXNwZWN0LlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzZXJ2aWNlUHJpbmNpcGFsKHNlcnZpY2U6IHN0cmluZykge1xuICAgIHJldHVybiBgc2VydmljZS1wcmluY2lwYWw6JHtzZXJ2aWNlLnJlcGxhY2UoL1xcLmFtYXpvbmF3c1xcLmNvbShcXC5jbik/JC8sICcnKX1gO1xuICB9XG59XG4iXX0=